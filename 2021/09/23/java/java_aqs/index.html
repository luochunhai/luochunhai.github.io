<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>AbstractQueuedSynchronizer - Summer</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Summer"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Summer"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="AQS (AbstractQueuedSynchronizer)  抽象类的队列式同步器原理概览AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。 CLH：Craig、Landin and H"><meta property="og:type" content="blog"><meta property="og:title" content="AbstractQueuedSynchronizer"><meta property="og:url" content="https://luochunhai.github.io/2021/09/23/java/java_aqs/"><meta property="og:site_name" content="Summer"><meta property="og:description" content="AQS (AbstractQueuedSynchronizer)  抽象类的队列式同步器原理概览AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。 CLH：Craig、Landin and H"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://luochunhai.github.io/2021/09/23/java/java_aqs/img.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/953b3a72617949fbbd8fef2ed76458c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/4e40cb45891e47709b1deeca3a9e3d6e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_12,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/6375d01be051492b8a81675f417d3396.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/51cfa72e5dd749b792afc2ff457205e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/c45dcff52e884bd88fc8efe2d71f6822.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/6ba4657746bf4acda2cf6e26e138a2ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/0d6d1c0a22374b95bc9df98ad229f270.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/dda46e67c2f8464092ec2ce603ffeb23.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/a2890de073884842a9227fd4b26a48de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/e79884071d9141ae9a9a448a276153e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_12,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/ee5190b3c4c041dd94bcba9ed301f25a.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/df9a419c029a47de8d31265d6a1133f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/78361e79df79425eb6549525931fb9df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/9edeeb8817454bfab069302e58a13ab5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="og:image" content="https://img-blog.csdnimg.cn/14cc40b6a6924b37b8a0e324ef99493f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16"><meta property="article:published_time" content="2021-09-23T06:01:13.000Z"><meta property="article:modified_time" content="2021-09-29T02:20:20.284Z"><meta property="article:author" content="Luo Chunhai"><meta property="article:tag" content="并发"><meta property="article:tag" content="java锁"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/09/23/java/java_aqs/img.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://luochunhai.github.io/2021/09/23/java/java_aqs/"},"headline":"AbstractQueuedSynchronizer","image":["https://luochunhai.github.io/2021/09/23/java/java_aqs/img.png","https://img-blog.csdnimg.cn/ee5190b3c4c041dd94bcba9ed301f25a.png"],"datePublished":"2021-09-23T06:01:13.000Z","dateModified":"2021-09-29T02:20:20.284Z","author":{"@type":"Person","name":"Luo Chunhai"},"publisher":{"@type":"Organization","name":"Summer","logo":{"@type":"ImageObject","url":{"text":"Summer"}}},"description":"AQS (AbstractQueuedSynchronizer)  抽象类的队列式同步器原理概览AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。 CLH：Craig、Landin and H"}</script><link rel="canonical" href="https://luochunhai.github.io/2021/09/23/java/java_aqs/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Summer</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/luochunhai"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Summer" href="http://www.luochunhai.club/"><i class="fas fa-link"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-23T06:01:13.000Z" title="9/23/2021, 2:01:13 PM">2021-09-23</time>发表</span><span class="level-item"><time dateTime="2021-09-29T02:20:20.284Z" title="9/29/2021, 10:20:20 AM">2021-09-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">1 小时读完 (大约11439个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">AbstractQueuedSynchronizer</h1><div class="content"><h1 id="AQS-AbstractQueuedSynchronizer-抽象类的队列式同步器"><a href="#AQS-AbstractQueuedSynchronizer-抽象类的队列式同步器" class="headerlink" title="AQS (AbstractQueuedSynchronizer)  抽象类的队列式同步器"></a>AQS (AbstractQueuedSynchronizer)  抽象类的队列式同步器</h1><h2 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h2><p>AQS核心思想是，<strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。<br><img src="/2021/09/23/java/java_aqs/img.png" alt="img.png"></p>
<span id="more"></span>

<h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><blockquote>
<p>AQS <code>是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效的构造出来。</code></p>
</blockquote>
<blockquote>
<p><code>为线程的同步和等待等操作提供一个基础模板类</code>。尽可能多的实现可重入锁，读写锁同步器所有需要的功能。队列同步器内部实现了线程的同步队列，独占或是共享的获取方式等，使其只需要少量的代码便可以实现目标功能。 一般来说，<code>AQS的子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步。</code><br>也就是说，使用ReentrantLock举例，外界调用ReentrantLock，ReentrantLock内部定义Sync，Sync是AQS的子类，在ReentrantLock的内部实现中调用Sync的方法，最后完成最终的功能，当然ReentrantLock内部稍复杂，又加入和公平锁和非公平锁。</p>
</blockquote>
<blockquote>
<p><code>抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...。</code><br><code>AbstractQueuedSynchronizer</code>，这个类也是在<code>java.util.concurrent.locks</code>下面。</p>
</blockquote>
<p>AQS，全名AbstractQueuedSynchronizer，是一个抽象类的队列式同步器，它的内部通过维护一个<code>状态volatile int state(共享资源)</code>，<code>一个FIFO线程等待队列</code>来实现同步功能。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><blockquote>
<p>所有通过AQS实现功能的类都是<code>通过修改state的状态来操作线程的同步状态</code>。比如在ReentrantLock中，一个锁中只有一个state状态，当state为0时，代表所有线程没有获取锁，当state为1时，代表有线程获取到了锁。通过是否能把state从0设置成1，当然，设置的方式是使用CAS设置，代表一个线程是否获取锁成功。</p>
</blockquote>
<p>state用关键字volatile修饰，代表着该共享资源的状态一更改就能被所有线程可见，而AQS的加锁方式本质上就是多个线程在竞争state，当state为0时代表线程可以竞争锁，不为0时代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个FIFO的等待队列中，这些线程会被UNSAFE.park()操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。</p>
<ul>
<li>AQS内部维护一个线程的队列。队列由内部的节点组成。 队列的节点为Node,节点分为<strong>SHARED和EXCLUSIVE</strong>分别时<strong>共享模式的节点和独占模式的节点</strong>。</li>
</ul>
<p>而这个等待队列其实就相当于一个<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40391011/article/details/104701988">CLH队列</a>，用一张原理图来表示大致如下：<br><img src="https://img-blog.csdnimg.cn/953b3a72617949fbbd8fef2ed76458c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="AQS支持两种资源分享的方式："><a href="#AQS支持两种资源分享的方式：" class="headerlink" title="AQS支持两种资源分享的方式："></a>AQS支持两种资源分享的方式：</h3><ul>
<li>Exclusive（独占，只有一个线程能执行，如ReentrantLock）</li>
<li>Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</li>
</ul>
<p>自定义的同步器继承AQS后，只需要实现·共享资源state的获取和释放方式·即可，其他如线程队列的维护（如获取资源失败入队/唤醒出队等）等操作，AQS在顶层已经实现了，</p>
<p>AQS代码内部提供了一系列操作锁和线程队列的方法，主要操作锁的方法包含以下几个：</p>
<ul>
<li>compareAndSetState()：利用CAS的操作来设置state的值-</li>
<li>tryAcquire(int)：独占方式获取锁。成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式释放锁。成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式释放锁。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式释放锁。如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
<li></li>
</ul>
<p>像<code>ReentrantLock就是实现了自定义的tryAcquire-tryRelease</code>，从而操作state的值来实现同步效果。</p>
<p>除此之外，AQS内部还定义了一个静态类Node，表示CLH队列的每一个结点，该结点的作用是对每一个等待获取资源做了封装，包含了需要同步的线程本身、线程等待状态…..</p>
<p>我们可以看下该类的一些重点变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** 表示共享模式下等待的Node */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">	<span class="comment">/** 表示独占模式下等待的mode */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">/** 下面几个为waitStatus的具体值 */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">	<span class="comment">/** 表示前面的结点 */</span></span><br><span class="line">	<span class="keyword">volatile</span> Node prev;</span><br><span class="line">	<span class="comment">/** 表示后面的结点 */</span></span><br><span class="line">	<span class="keyword">volatile</span> Node next;</span><br><span class="line">	<span class="comment">/**当前结点装载的线程，初始化时被创建，使用后会置空*/</span></span><br><span class="line">	<span class="keyword">volatile</span> Thread thread;</span><br><span class="line">	<span class="comment">/**链接到下一个节点的等待条件，用到Condition的时候会使用到*/</span></span><br><span class="line">	Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码里面定义了一个表示当前Node结点等待状态的字段waitStatus，该字段的取值包含了CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)、0，这五个值代表了不同的特定场景：</p>
<ul>
<li><strong>CANCELLED</strong>：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL（记住这个-1的值，因为后面我们讲的时候经常会提到）</li>
<li><strong>CONDITION</strong>：表示结点等待在Condition上，当其他线程调用了Condition的SIGNAL()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。(注：Condition是AQS的一个组件，后面会细说)</li>
<li><strong>PROPAGATE</strong>：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li>0：新结点入队时的默认状态。</li>
</ul>
<p>也就是说，当waitStatus为负值表示结点处于有效等待状态，为正值的时候表示结点已被取消。</p>
<p>在AQS内部中还维护了两个Node对象head和tail，一开始默认都为null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head; </span><br><span class="line">private transient volatile Node tail;   </span><br></pre></td></tr></table></figure>

<p>讲完了AQS的一些基础定义，我们就可以开始学习同步的具体运行机制了，为了更好的演示，我们用<code>ReentrantLock</code>作为使用入口，一步步跟进源码探究AQS底层是如何运作的，这里说明一下，因为ReentrantLock底层调用的AQS是<code>独占模式</code>，所以下文讲解的AQS源码也是针对独占模式的操作</p>
<h2 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h2><blockquote>
<p><code>ReentrantLock</code>和<code>synchronized</code>功能类似，使用AQS的独占模式，只有一个线程可以获取锁。<br><img src="https://img-blog.csdnimg.cn/4e40cb45891e47709b1deeca3a9e3d6e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><p>我们都知道，ReentrantLock的加锁和解锁方法分别为lock()和unLock()，我们先来看获取锁的方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">	setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	acquire(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中compareAndSetState(0, 1)<br>如果返回true就代表着之前state是0，也就是当前无线程获取锁，同时当前线程获取锁成功了，将独占线程设置为当前线程。 如果是false就代表当前有线程占用，当前占用的线程有2个可能</p>
<ul>
<li>当前线程在占用，因为是可重入锁，之后同样会获取锁</li>
<li>其他线程在占用，在其他线程占用期间，当前线程需要等待</li>
</ul>
<p>逻辑很简单，线程进来后直接利用CAS尝试抢占锁，如果抢占成功state值回被改为1，且设置对象独占锁线程为当前线程，否则就调用acquire(1)再次尝试获取锁。</p>
<p>我们假定有两个线程A和B同时竞争锁，A进来先抢占到锁，此时的AQS模型图就类似这样：<br><img src="https://img-blog.csdnimg.cn/6375d01be051492b8a81675f417d3396.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><blockquote>
<p>acquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了。</p>
</blockquote>
<blockquote>
<p>acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次tryAcquire(int)方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">	selfInterrupt();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>acquire(1)包含整个获取锁，如果获取不到就等待的操作</strong></p>
<p>acquire包含了几个函数的调用，</p>
<ul>
<li><strong>tryAcquire</strong>：尝试直接获取锁，如果成功就直接返回；</li>
<li><strong>addWaiter</strong>：获取不到锁时,说明有其他线程目前正在占用锁, 将该线程加入等待队列FIFO的尾部，并标记为独占模式；</li>
<li><strong>acquireQueued</strong>：线程阻塞在等待队列中获取锁，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li><strong>selfInterrupt</strong>：自我中断，就是既拿不到锁，又在等待时被中断了，线程就会进行自我中断selfInterrupt()，将中断补上。</li>
</ul>
<p>我们一个个来看源码，并结合上面的两个线程来做场景分析。</p>
<h5 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h5><blockquote>
<p>在tryAcquire(arg)中是尝试获取锁,是由ReentrantLock提供的,逻辑比较简单<br>当前无线程占有锁时,即state为0时,获取锁 当前有线程占有锁,但当前占有锁的线程是当前线程时,因为ReentrantLock是可重入锁,获取锁,并把state+1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> Thread current=Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c=getState();</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,acquires))&#123;</span><br><span class="line">	setExclusiveOwnerThread(current);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(current==getExclusiveOwnerThread())&#123;</span><br><span class="line">	<span class="comment">//当前占有锁的线程是当前线程时,因为ReentrantLock是可重入锁,获取锁,并把state+1</span></span><br><span class="line">	<span class="keyword">int</span> nextc=c+acquires;</span><br><span class="line">	<span class="keyword">if</span>(nextc&lt; <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// overflow    </span></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">	setState(nextc);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当线程B进来后，nonfairTryAcquire方法首先会获取state的值，如果为0，则正常获取该锁，不为0的话判断是否是当前线程占用了，是的话就累加state的值，这里的累加也是为了配合释放锁时候的次数，从而实现可重入锁的效果。</p>
<p>当然，因为之前锁已经被线程A占领了，所以这时候tryAcquire会返回false，继续下面的流程。</p>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><p>获取不到锁时,说明有其他线程目前正在占用锁,将当前线程包装成节点放入同步队列 将该线程加入等待队列FIFO的尾部，并标记为独占模式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 先尝试快速入队，如果入队成功直接返回，如果失败（存在竞态）就使用cas反复入队直到成功为止</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span></span>&#123;</span><br><span class="line">	Node node=<span class="keyword">new</span> Node(Thread.currentThread(),mode);</span><br><span class="line">	<span class="comment">// Try the fast path of enq; backup to full enq on failure </span></span><br><span class="line">	<span class="comment">//  //快速入队</span></span><br><span class="line">	Node pred=tail;</span><br><span class="line">	<span class="keyword">if</span>(pred!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	node.prev=pred;</span><br><span class="line">	<span class="keyword">if</span>(compareAndSetTail(pred,node))&#123;</span><br><span class="line">	pred.next=node;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enq(node);</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先会创建一个和当前线程绑定的Node节点，Node为双向链表。此时等待队列中的tail指针为空，直接调用enq(node)方法将当前线程加入等待队列尾部，然后返回当前结点的前驱结点，</p>
<h5 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h5><p>用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span></span>&#123;</span><br><span class="line">	<span class="comment">// CAS&quot;自旋&quot;，直到成功加入队尾     </span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	Node t=tail;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;    <span class="comment">// 队列为空，初始化一个Node结点作为Head结点，并将tail结点也指向它                </span></span><br><span class="line">	<span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">	tail=head;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;          <span class="comment">// 把当前结点插入队列尾部             </span></span><br><span class="line">	node.prev=t;</span><br><span class="line">	<span class="keyword">if</span>(compareAndSetTail(t,node))&#123;</span><br><span class="line">	t.next=node;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一遍循环时，tail指针为空，初始化一个Node结点，并把head和tail结点都指向它，然后第二次循环进来之后，tail结点不为空了，就将当前的结点加入到tail结点后面，也就是这样：</p>
<p><img src="https://img-blog.csdnimg.cn/51cfa72e5dd749b792afc2ff457205e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="作者：D糊涂小天才z https://www.bilibili.com/read/cv8757383/ 出处：bilibili"><br>如果此时有另一个线程C进来的话，发现锁已经被A拿走了，然后队列里已经有了线程B，那么线程C就只能乖乖排到线程B的后面去，<br><img src="https://img-blog.csdnimg.cn/c45dcff52e884bd88fc8efe2d71f6822.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>入队完成之后再判断一次当前是否有可能获得锁，也就是前一个节点是head的话， 前一个线程有可能已经释放了，再获取一次，如果获取成功，设置当前节点为头节点，整个获取过程完成。</strong></p>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><p>接着解读方法，通过tryAcquire()和addWaiter()，我们的线程还是没有拿到资源，并且还被排到了队列的尾部，如果让你来设计的话，这个时候你会怎么处理线程呢？其实答案也很简单，能做的事无非两个：</p>
<p><strong>1、循环让线程再抢资源。但仔细一推敲就知道不合理，因为如果有多个线程都参与的话，你抢我也抢只会降低系统性能 2、进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源</strong></p>
<p><code>毫无疑问，选择2更加靠谱，acquireQueued方法做的也是这样的处理：</code></p>
<p><code>acquireQueued()</code>用于队列中的线程<strong>自旋地以独占且不可中断的方式获取同步状态（acquire）</strong>，直到拿到锁之后再返回。该方法的实现分成两部分：<strong>如果当前节点已经成为头结点，尝试获取锁（tryAcquire）成功，然后返回；否则检查当前节点是否应该被park，然后将该线程park并且检查当前线程是否被可以被中断。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node,<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> failed=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;   <span class="comment">// 标记是否会被中断   </span></span><br><span class="line">	<span class="keyword">boolean</span> interrupted=<span class="keyword">false</span>;   <span class="comment">// CAS自旋   </span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">// 获取当前结点的前结点    </span></span><br><span class="line"><span class="keyword">final</span> Node p=node.predecessor();</span><br><span class="line">	<span class="keyword">if</span>(p==head&amp;&amp;tryAcquire(arg))&#123;</span><br><span class="line">	setHead(node);</span><br><span class="line">	p.next=<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// help GC    </span></span><br><span class="line">	failed=<span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> interrupted;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(shouldParkAfterFailedAcquire(p,node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">	interrupted=<span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(failed)    <span class="comment">// 获取锁失败，则将此线程对应的node的waitStatus改为CANCEL    </span></span><br><span class="line">	cancelAcquire(node);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="shouldParkAfterFailedAcquire-Node-Node"><a href="#shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="shouldParkAfterFailedAcquire(Node, Node)"></a>shouldParkAfterFailedAcquire(Node, Node)</h5><p>shouldParkAfterFailedAcquire方法通过对当前节点的前一个节点的状态进行判断，对当前节点做出不同的操作，至于每个Node的状态表示，可以参考接口文档。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred,Node node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ws=pred.waitStatus;</span><br><span class="line">	<span class="keyword">if</span>(ws==Node.SIGNAL)   <span class="comment">// 前驱结点等待状态为&quot;SIGNAL&quot;，那么自己就可以安心等待被唤醒了   </span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(ws&gt;<span class="number">0</span>)&#123;   <span class="comment">/*    * 前驱结点被取消了，通过循环一直往前找，直到找到等待状态有效的结点(等待状态值小于等于0) ，    * 然后排在他们的后边，至于那些被当前Node强制&quot;靠后&quot;的结点，因为已经被取消了，也没有引用链，    * 就等着被GC了    */</span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	node.prev=pred=pred.prev;</span><br><span class="line">	&#125;<span class="keyword">while</span>(pred.waitStatus&gt;<span class="number">0</span>);</span><br><span class="line">	pred.next=node;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;   <span class="comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL   </span></span><br><span class="line">	compareAndSetWaitStatus(pred,ws,Node.SIGNAL);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>acquireQueued方法的流程是这样的：</p>
<ul>
<li><p>1、CAS自旋，先判断当前传入的Node的前结点是否为head结点，是的话就尝试获取锁，获取锁成功的话就把当前结点置为head，之前的head置为null(方便GC)，然后返回</p>
</li>
<li><p>2、如果前驱结点不是head或者加锁失败的话，就调用 <code>shouldParkAfterFailedAcquire</code>，将前驱节点的<code>waitStatus变为了SIGNAL=-1</code>，最后执行 parkAndChecknIterrupt 方法，调用    <code>LockSupport.park()</code><br>挂起当前线程，parkAndCheckInterrupt在挂起线程后会判断线程是否被中断，如果被中断的话，就会重新跑acquireQueued方法的CAS自旋操作，直到获取资源。</p>
</li>
</ul>
<blockquote>
<p>ps：LockSupport.park方法会让当前线程进入waitting状态，在这种状态下，线程被唤醒的情况有两种，一是被unpark()，二是被interrupt()，所以，如果是第二种情况的话，需要返回被中断的标志，然后在acquire顶层方法的窗口那里自我中断补上</p>
</blockquote>
<p>此时，因为线程A还未释放锁，所以线程B状态都是被挂起的，</p>
<p><img src="https://img-blog.csdnimg.cn/6ba4657746bf4acda2cf6e26e138a2ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>到这里，加锁的流程就分析完了.</p>
<h5 id="获取锁并等待的过程"><a href="#获取锁并等待的过程" class="headerlink" title="获取锁并等待的过程:"></a>获取锁并等待的过程:</h5><p>当lock()执行的时候：</p>
<ul>
<li>先快速获取锁，当前没有线程执行的时候直接获取锁</li>
<li>尝试获取锁，当没有线程执行或是当前线程占用锁，可以直接获取锁</li>
<li>将当前线程包装为node放入同步队列，设置为尾节点</li>
<li>前一个节点如果为头节点，再次尝试获取一次锁</li>
<li>将前一个有效节点设置为SIGNAL</li>
<li>然后阻塞直到被唤醒</li>
</ul>
<p>为了方便你们更加清晰理解，我加多一张流程图<br><img src="https://img-blog.csdnimg.cn/0d6d1c0a22374b95bc9df98ad229f270.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>说完了加锁，我们来看看释放锁是怎么做的，AQS中释放锁的方法是release()，当调用该方法时会释放指定量的资源 (也就是锁) ，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p>
<h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><p>当ReentrantLock进行释放锁操作时，调用的是AQS的release(1)操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tryRelease(arg))&#123;</span><br><span class="line">	Node h=head;</span><br><span class="line">	<span class="keyword">if</span>(h!=<span class="keyword">null</span>&amp;&amp;h.waitStatus!=<span class="number">0</span>)</span><br><span class="line">	unparkSuccessor(h);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h5><p>代码上可以看出，核心的逻辑都在tryRelease方法中，该方法的作用是释放资源，AQS里该方法没有具体的实现，需要由自定义的同步器去实现，我们看下ReentrantLock代码中对应方法的源码：</p>
<blockquote>
<p>在tryRelease(arg)中会将锁释放一次，如果当前state是1，且当前线程是正在占用的线程，释放锁成功，返回true，否则因为是可重入锁，释放一次可能还在占用，应一直释放直到state为0为止</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c=getState()-releases;</span><br><span class="line">	<span class="keyword">if</span>(Thread.currentThread()!=getExclusiveOwnerThread())</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="keyword">boolean</span> free=<span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">	free=<span class="keyword">true</span>;</span><br><span class="line">	setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setState(c);</span><br><span class="line">	<span class="keyword">return</span> free;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>tryRelease方法会减去state对应的值，如果state为0，也就是已经彻底释放资源，就返回true，并且把独占的线程置为null，否则返回false。</p>
<p>此时AQS中的数据就会变成这样：<br><img src="https://img-blog.csdnimg.cn/dda46e67c2f8464092ec2ce603ffeb23.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><p>完全释放资源后，当前线程要做的就是唤醒CLH队列中第一个在等待资源的线程，也就是head结点后面的线程，此时调用的方法是unparkSuccessor()，</p>
<blockquote>
<p>然后优先找下一个节点，如果取消了就从尾节点开始找，找到最前面一个可用的节点</p>
</blockquote>
<p>将其取消阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ws=node.waitStatus;</span><br><span class="line"><span class="keyword">if</span>(ws&lt; <span class="number">0</span>)      <span class="comment">//将head结点的状态置为0         </span></span><br><span class="line">compareAndSetWaitStatus(node,ws,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//找到下一个需要唤醒的结点s    </span></span><br><span class="line">Node s=node.next;</span><br><span class="line"><span class="comment">//如果为空或已取消     </span></span><br><span class="line"><span class="keyword">if</span>(s==<span class="keyword">null</span>||s.waitStatus&gt;<span class="number">0</span>)&#123;</span><br><span class="line">s=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 从后向前，直到找到等待状态小于0的结点，前面说了，结点waitStatus小于0时才有效         </span></span><br><span class="line"><span class="keyword">for</span>(Node t=tail;t!=<span class="keyword">null</span>&amp;&amp;t!=node;t=t.prev)</span><br><span class="line"><span class="keyword">if</span>(t.waitStatus&lt;=<span class="number">0</span>)</span><br><span class="line">s=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到有效的结点，直接唤醒     </span></span><br><span class="line"><span class="keyword">if</span>(s!=<span class="keyword">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的逻辑很简单，就是先将head的结点状态置为0，避免下面找结点的时候再找到head，然后找到队列中最前面的有效结点，然后唤醒，我们假设这个时候线程A已经释放锁，那么此时队列中排最前边竞争锁的线程B就会被唤醒。然后被唤醒的线程B就会尝试用CAS获取锁，<strong>回到acquireQueued方法的逻辑，</strong></p>
<blockquote>
<p>阻塞在acquireQueued的地方在唤醒之后开始继续执行，当前节点已经是最前面的一个可用（未取消）节点了,经过不断的for循环以及在shouldParkAfterFailedAcquire中不断向前寻找可用节点，因此这个被唤醒的节点一定可以使其之前的节点为head。然后获取锁成功。</p>
</blockquote>
<blockquote>
<p>但是此时节点会与新加入的节点竞争，也就是不公平锁的由来。</p>
</blockquote>
<blockquote>
<p>在公平锁中，在tryAcquire时会判断之前是否有等待的节点hasQueuedPredecessors(),如果有就不会再去获取锁了,因此能保证顺序执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">// 获取当前结点的前结点  </span></span><br><span class="line"><span class="keyword">final</span> Node p=node.predecessor();</span><br><span class="line">	<span class="keyword">if</span>(p==head&amp;&amp;tryAcquire(arg))&#123;</span><br><span class="line">	setHead(node);</span><br><span class="line">	p.next=<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// help GC   </span></span><br><span class="line">	failed=<span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> interrupted;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(shouldParkAfterFailedAcquire(p,node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">	interrupted=<span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当线程B获取锁之后，会把当前结点赋值给head，然后原先的前驱结点 (也就是原来的head结点) 去掉引用链，方便回收，这样一来，线程B获取锁的整个过程就完成了，此时AQS的数据就会变成这样：<br><img src="https://img-blog.csdnimg.cn/a2890de073884842a9227fd4b26a48de.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>到这里，我们已经分析完了AQS独占模式下加锁和释放锁的过程，也就是tryAccquire-&gt;tryRelease这一链条的逻辑，除此之外，AQS中还支持共享模式的同步，这种模式下关于锁的操作核心其实就是tryAcquireShared-&gt;tryReleaseShared这两个方法，我们可以简单看下</p>
<h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><p><img src="https://img-blog.csdnimg.cn/e79884071d9141ae9a9a448a276153e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>ReentrantReadWriteLock是Java中<code>读写锁</code>的实现，<code>写写互斥，读写互斥，读读共享</code>。读写锁在内部分为读锁和写锁，因为我们要探索共享模式，因此更关注<code>读锁</code>。</strong></p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>AQS中，共享模式获取锁的顶层入口方法是<code>acquireShared</code>，该方法会获取指定数量的资源，成功的话就直接返回，失败的话就进入等待队列，直到获取资源，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tryAcquireShared(arg)&lt; <span class="number">0</span>)</span><br><span class="line">	doAcquireShared(arg);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该方法里包含了两个方法的调用，</p>
<ul>
<li>tryAcquireShared：尝试获取一定资源的锁，返回的值代表获取锁的状态。</li>
<li>doAcquireShared：进入等待队列，并循环尝试获取锁，直到成功。</li>
</ul>
<h5 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h5><p>tryAcquireShared在AQS里没有实现，同样由自定义的同步器去完成具体的逻辑，像一些较为常见的并发工具<code>Semaphore、CountDownLatch</code>里就有对该方法的自定义实现，虽然实现的逻辑不同，但方法的作用是一样的，就是<code>获取一定资源的资源，然后根据返回值判断是否还有剩余资源，从而决定下一步的操作</code>。</p>
<p>返回值有三种定义：</p>
<ul>
<li>负值代表获取失败； <code>(当前有写锁，返回-1，即未获取共享锁，需要执行下一步doAcquireShared)</code></li>
<li>0代表获取成功，但没有剩余的资源，也就是state已经为0；</li>
<li>正值代表获取成功，而且state还有剩余，其他线程可以继续领取</li>
</ul>
<p>当返回值小于0时，证明此次获取一定数量的锁失败了，然后就会走doAcquireShared方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span></span>&#123;</span><br><span class="line">	Thread current=Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c=getState();</span><br><span class="line">	<span class="keyword">if</span>(exclusiveCount(c)!=<span class="number">0</span>&amp;&amp;</span><br><span class="line">	getExclusiveOwnerThread()!=current)</span><br><span class="line">	<span class="keyword">return</span>-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r=sharedCount(c);</span><br><span class="line">	<span class="keyword">if</span>(!readerShouldBlock()&amp;&amp;</span><br><span class="line">	r&lt;MAX_COUNT &amp;&amp;</span><br><span class="line">	compareAndSetState(c,c+SHARED_UNIT))&#123;</span><br><span class="line">	<span class="comment">//设置firstReader，计算数量，略</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置共享锁需要修改state的数量，表示获取共享锁的线程的数量，当共享锁的获取存在竞争时，即<code>compareAndSetState(c, c + SHARED_UNIT))可能设置失败</code>，此时进入fullTryAcquireShared(current)进行获取共享锁的完整版操作。</p>
</blockquote>
<blockquote>
<p>也就是说共享锁获取时：<br>如果当前没有独占锁在占用，AQS根据其实现类的tryAcquireShared来实现让一个共享锁直接获取到锁(可以直接执行)<br>当有独占锁在占用是，让共享锁去等待直到独占锁解锁为止，也就是doAcquireShared(arg)的逻辑</p>
</blockquote>
<h5 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5><p>此方法的作用是将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回，这是它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line"><span class="comment">// 加入队列尾部</span></span><br><span class="line"><span class="keyword">final</span> Node node=addWaiter(Node.SHARED);</span><br><span class="line">	<span class="keyword">boolean</span> failed=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> interrupted=<span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// CAS自旋 </span></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">final</span> Node p=node.predecessor();</span><br><span class="line">	<span class="comment">// 判断前驱结点是否是head </span></span><br><span class="line">	<span class="keyword">if</span>(p==head)&#123;</span><br><span class="line">	<span class="comment">// 尝试获取一定数量的锁     </span></span><br><span class="line">	<span class="keyword">int</span> r=tryAcquireShared(arg);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// 获取锁成功，而且还有剩余资源，就设置当前结点为head，并继续唤醒下一个线程      </span></span><br><span class="line">	setHeadAndPropagate(node,r);</span><br><span class="line">	<span class="comment">// 让前驱结点去掉引用链，方便被GC   </span></span><br><span class="line">	p.next=<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// help GC    </span></span><br><span class="line">	<span class="keyword">if</span>(interrupted)</span><br><span class="line">	selfInterrupt();</span><br><span class="line">	failed=<span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 跟独占模式一样，改前驱结点waitStatus为-1，并且当前线程挂起，等待被唤醒  </span></span><br><span class="line">	<span class="keyword">if</span>(shouldParkAfterFailedAcquire(p,node)&amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">	interrupted=<span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(failed)</span><br><span class="line">	cancelAcquire(node);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>doAcquireShared(arg) 除了将线程封装成节点入队外还表达了3个思想：</p>
<ul>
<li><p>什么时候该执行</p>
</li>
<li><p>什么时候该传播</p>
</li>
<li><p>什么时候该等待（阻塞） 其中入队、执行和等待的逻辑基本和独占锁一样，</p>
</li>
<li><p>入队：都是加入等待队列的末尾，成为tail节点；</p>
</li>
<li><p>执行：判断当前节点的前一个节点是不是头节点，如果是的话尝试获取锁，如果获取到了就执行；</p>
</li>
<li><p>等待：获取不到或前一个节点不是头节点就代表该线程需要暂时等待，直到被叫醒为止。设置前一个节点为SIGNAL状态，然后进入等待。</p>
</li>
<li></li>
</ul>
<p>其中不同的就是共享锁的传播逻辑：</p>
<p>想象一下，当前有一个写锁正在占用，有多个读锁在等待，当写锁释放时，第二个线程也就是想要获取读锁的线程就可以获取锁了。获取到之后当前正在用的锁就是读锁了，那后面的读锁呢，因为读锁是共享的，后面的读锁应该也能够依次获取读锁，也就是读锁的传播机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node,<span class="keyword">int</span> propagate)</span></span>&#123;</span><br><span class="line">Node h=head;</span><br><span class="line"><span class="comment">// head指向自己   </span></span><br><span class="line">setHead(node);</span><br><span class="line"><span class="comment">// 如果还有剩余量，继续唤醒下一个邻居线程    </span></span><br><span class="line"><span class="keyword">if</span>(propagate&gt;<span class="number">0</span>||h==<span class="keyword">null</span>||h.waitStatus&lt; <span class="number">0</span>)&#123;</span><br><span class="line">Node s=node.next;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="keyword">null</span>||s.isShared())</span><br><span class="line">doReleaseShared();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前的节点设置为头节点，判断如果是共享锁，执行doReleaseShared()，唤醒当前节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">Node h=head;</span><br><span class="line"><span class="keyword">if</span>(h!=<span class="keyword">null</span>&amp;&amp;h!=tail)&#123;</span><br><span class="line"><span class="keyword">int</span> ws=h.waitStatus;</span><br><span class="line"><span class="keyword">if</span>(ws==Node.SIGNAL)&#123;</span><br><span class="line"><span class="keyword">if</span>(!compareAndSetWaitStatus(h,Node.SIGNAL,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ws==<span class="number">0</span>&amp;&amp;</span><br><span class="line">!compareAndSetWaitStatus(h,<span class="number">0</span>,Node.PROPAGATE))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h==head)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前节点唤醒之后doAcquireShared(int arg)会继续执行,因为之前的节点被设置为头节点,如果后续是获取共享锁的节点会继续执行setHeadAndPropagate,一直传播下去直到遇到获取独占锁的节点。</p>
<p>看到这里，你会不会一点熟悉的感觉，这个方法的逻辑怎么跟上面那个acquireQueued() 那么类似啊？对的，其实两个流程并没有太大的差别。<strong>只是doAcquireShared()比起独占模式下的获取锁上多了一步唤醒后继线程的操作，当获取完一定的资源后，发现还有剩余的资源，就继续唤醒下一个邻居线程，这才符合”共享”的思想嘛。</strong></p>
<p>这里我们可以提出一个<strong>疑问</strong>，<code>共享模式下，当前线程释放了一定数量的资源，但这部分资源满足不了下一个等待结点的需要的话，那么会怎么样？</code></p>
<p>按照正常的思维，共享模式是可以多个线程同时执行的才对，所以，多个线程的情况下，如果老大释放完资源，但这部分资源满足不了老二，但能满足老三，那么老三就可以拿到资源。可事实是，从源码设计中可以看出，如果真的发生了这种情况，老三是拿不到资源的，因为<code>等待队列是按顺序排列的</code>，老二的资源需求量大，会把后面量小的老三以及老四、老五等都给卡住。从这一个角度来看，虽然AQS严格保证了顺序，但也降低了并发能力</p>
<p>接着往下说吧，唤醒下一个邻居线程的逻辑在<code>doReleaseShared()</code>中，我们放到下面的释放锁来解析。</p>
<h5 id="共享锁的获取总结如下："><a href="#共享锁的获取总结如下：" class="headerlink" title="共享锁的获取总结如下："></a>共享锁的获取总结如下：</h5><ul>
<li>尝试获取共享锁，如果当前是共享锁或无锁，设置共享锁的state,获取锁</li>
<li>如果当前是写锁，进入等待流程</li>
<li>入队，加入等待队列的末尾，成为tail节点</li>
<li>判断当前节点的前一个节点是不是头节点，如果是的话尝试获取锁，如果获取到了就执行</li>
<li>获取不到或前一个节点不是头节点就代表该线程需要暂时等待，直到被叫醒为止。设置前一个节点为SIGNAL状态，然后进入等待</li>
<li>如果可以获取到锁，设置头节点并进入共享锁节点传播流程</li>
</ul>
<h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><p>共享模式释放锁的顶层方法是releaseShared，<strong>它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源</strong>。下面是<code>releaseShared()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tryReleaseShared(arg))&#123;</span><br><span class="line">	doReleaseShared();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该方法同样包含两部分的逻辑：</p>
<ul>
<li>tryReleaseShared：释放资源。</li>
<li>doAcquireShared：唤醒后继结点。</li>
</ul>
<p>跟tryAcquireShared方法一样，tryReleaseShared在AQS中没有具体的实现，由子同步器自己去定义，但功能都一样，就是释放一定数量的资源。</p>
<p>释放完资源后，线程不会马上就收工，而是唤醒等待队列里最前排的等待结点。</p>
<h5 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h5><p>在tryReleaseShared(arg)，基本就是tryAcquireShared(int unused)的反向操作</p>
<p>将设置的HoldCounter减少，firstReader设置null，state减少,将tryAcquireShared(int unused)添加的状态全部反向还原回去</p>
<p>当共享锁全部释放完毕，返回true，否则返回false</p>
<h5 id="doAcquireShared-1"><a href="#doAcquireShared-1" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5><p>唤醒后继结点的工作在doReleaseShared()方法中完成，我们可以看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="comment">// 获取等待队列中的head结点 </span></span><br><span class="line">Node h=head;</span><br><span class="line"><span class="keyword">if</span>(h!=<span class="keyword">null</span>&amp;&amp;h!=tail)&#123;</span><br><span class="line"><span class="keyword">int</span> ws=h.waitStatus;</span><br><span class="line"><span class="comment">// head结点waitStatus = -1,唤醒下一个结点对应的线程 </span></span><br><span class="line"><span class="keyword">if</span>(ws==Node.SIGNAL)&#123;</span><br><span class="line"><span class="keyword">if</span>(!compareAndSetWaitStatus(h,Node.SIGNAL,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// loop to recheck cases</span></span><br><span class="line"><span class="comment">// 唤醒后继结点   </span></span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ws==<span class="number">0</span>&amp;&amp;!compareAndSetWaitStatus(h,<span class="number">0</span>,Node.PROPAGATE))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// loop on failed CAS   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h==head)</span><br><span class="line"><span class="comment">// loop if head changed    break;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码没什么特别的，就是如果等待队列head结点的waitStatus为-1的话，就直接唤醒后继结点，唤醒的方法unparkSuccessor()在上面已经讲过了，这里也没必要再复述。</p>
<p>总的来看，AQS共享模式的运作流程和独占模式很相似。</p>
<h1 id="2-Condition"><a href="#2-Condition" class="headerlink" title="2. Condition"></a>2. Condition</h1><p>介绍完了AQS的核心功能，我们再扩展一个知识点，在AQS中，除了提供独占/共享模式的加锁/解锁功能，它还对外提供了关于Condition的一些操作方法。</p>
<p>Condition是个接口，在jdk1.5版本后设计的，基本的方法就是<code>await()和SIGNAL()</code>方法，功能大概就对应Object的wait()和notify()，<code>Condition必须要配合锁一起使用</code>，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现<br>，AQS中就定义了一个类ConditionObject来实现了这个接口，<br><img src="https://img-blog.csdnimg.cn/ee5190b3c4c041dd94bcba9ed301f25a.png" alt="在这里插入图片描述"><br>那么它应该怎么用呢？我们可以简单写个demo来看下效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		Condition condition = lock.newCondition();</span><br><span class="line">		Thread tA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程A加锁成功&quot;</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;线程A执行await被挂起&quot;</span>);</span><br><span class="line">				condition.await();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程A被唤醒成功&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程A释放锁成功&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread tB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程B加锁成功&quot;</span>);</span><br><span class="line">				condition.SIGNAL();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程B唤醒线程A&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">				System.out.println(<span class="string">&quot;线程B释放锁成功&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		tA.start();</span><br><span class="line">		tB.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行main函数后结果输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程A加锁成功 </span><br><span class="line">线程A执行await被挂起 </span><br><span class="line">线程B加锁成功</span><br><span class="line"> 线程B唤醒线程A </span><br><span class="line"> 线程B释放锁成功 </span><br><span class="line"> 线程A被唤醒成功 </span><br><span class="line"> 线程A释放锁成功</span><br></pre></td></tr></table></figure>

<p>代码执行的结果很容易理解，<strong>线程A先获取锁，然后调用await()方法挂起当前线程并释放锁，线程B这时候拿到锁，然后调用SIGNAL唤醒线程A。</strong></p>
<p>毫无疑问，这两个方法让线程的状态发生了变化，我们仔细来研究一下，</p>
<p>翻看AQS的源码，我们会发现Condition中定义了两个属性<code>firstWaiter和lastWaiter</code>，前面说了，AQS中包含了一个FIFO的CLH等待队列，每个Conditon对象就包含这样一个等待队列，而这两个属性分别表示的是等待队列中的首尾结点，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p>注意：Condition当中的等待队列和AQS主体的同步等待队列是分开的，两个队列虽然结构体相同，但是作用域是分开的</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>先看await()的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"><span class="comment">// 将当前线程加入到等待队列中     </span></span><br><span class="line">Node node=addConditionWaiter();</span><br><span class="line"><span class="comment">// 完全释放占有的资源，并返回资源数     </span></span><br><span class="line"><span class="keyword">int</span> savedState=fullyRelease(node);</span><br><span class="line"><span class="keyword">int</span> interruptMode=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 循环判断当前结点是不是在Condition的队列中，是的话挂起     </span></span><br><span class="line"><span class="keyword">while</span>(!isOnSyncQueue(node))&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>((interruptMode=checkInterruptWhileWaiting(node))!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(acquireQueued(node,savedState)&amp;&amp;interruptMode!=THROW_IE)</span><br><span class="line">interruptMode=REINTERRUPT;</span><br><span class="line"><span class="keyword">if</span>(node.nextWaiter!=<span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// clean up if cancelled         </span></span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span>(interruptMode!=<span class="number">0</span>)</span><br><span class="line">reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程调用 <strong>Condition.await()方法，将会以当前线程构造结点，这个结点的waitStatus赋值为Node.CONDITION，</strong> 也就是-2，并将结点从尾部加入等待队列，然后尾部结点就会指向这个新增的结点，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node t=lastWaiter;</span><br><span class="line"><span class="comment">// If lastWaiter is cancelled, clean out.     </span></span><br><span class="line"><span class="keyword">if</span>(t!=<span class="keyword">null</span>&amp;&amp;t.waitStatus!=Node.CONDITION)&#123;</span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line">t=lastWaiter;</span><br><span class="line">&#125;</span><br><span class="line">Node node=<span class="keyword">new</span> Node(Thread.currentThread(),Node.CONDITION);</span><br><span class="line"><span class="keyword">if</span>(t==<span class="keyword">null</span>)</span><br><span class="line">firstWaiter=node;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t.nextWaiter=node;</span><br><span class="line">lastWaiter=node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们依然用上面的demo来演示，此时，线程A获取锁并调用Condition.await()方法后，AQS内部的数据结构会变成这样：<br><img src="https://img-blog.csdnimg.cn/df9a419c029a47de8d31265d6a1133f1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在Condition队列中插入对应的结点后，线程A会释放所持有的资源，走到while循环那层逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isOnSyncQueue(node))&#123;</span><br><span class="line">	LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span>((interruptMode=checkInterruptWhileWaiting(node))!=<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>isOnSyncQueue方法的会判断当前的线程节点是不是在同步队列中，这个时候此结点还在Condition队列中，所以该方法返回false，这样的话循环会一直持续下去，线程被挂起，等待被唤醒，此时，线程A的流程暂时停止了。</p>
<p>当线程A调用await()方法挂起的时候，线程B获取到了线程A释放的资源，然后执行SIGNAL()方法：</p>
<h4 id="SIGNAL"><a href="#SIGNAL" class="headerlink" title="SIGNAL"></a>SIGNAL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">SIGNAL</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!isHeldExclusively())</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	Node first=firstWaiter;</span><br><span class="line">	<span class="keyword">if</span>(first!=<span class="keyword">null</span>)</span><br><span class="line">	doSIGNAL(first);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>先判断当前线程是否为获取锁的线程，如果不是则直接抛出异常。接着调用doSIGNAL()方法来唤醒线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSIGNAL</span><span class="params">(Node first)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 循环，从队列一直往后找不为空的首结点     </span></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((firstWaiter=first.nextWaiter)==<span class="keyword">null</span>)</span><br><span class="line">	lastWaiter=<span class="keyword">null</span>;</span><br><span class="line">	first.nextWaiter=<span class="keyword">null</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span>(!transferForSIGNAL(first)&amp;&amp;(first=firstWaiter)!=<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSIGNAL</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">	<span class="comment">// CAS循环，将结点的waitStatus改为0     </span></span><br><span class="line">	<span class="keyword">if</span>(!compareAndSetWaitStatus(node,Node.CONDITION,<span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 上面已经分析过，此方法会把当前结点加入到等待队列中，并返回前驱结点     </span></span><br><span class="line">	Node p=enq(node);</span><br><span class="line">	<span class="keyword">int</span> ws=p.waitStatus;</span><br><span class="line">	<span class="keyword">if</span>(ws&gt;<span class="number">0</span>||!compareAndSetWaitStatus(p,ws,Node.SIGNAL))</span><br><span class="line">	LockSupport.unpark(node.thread);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从doSIGNAL的代码中可以看出，这时候程序寻找的是Condition等待队列中首结点firstWaiter的结点，此时该结点指向的是线程A的结点，所以之后的流程作用的都是线程A的结点。</p>
<p>这里分析下<code>transferForSIGNAL</code>方法，<strong>先通过CAS自旋将结点waitStatus改为0，然后就把结点放入到同步队列 (此队列不是Condition的等待队列) 中，然后再用CAS将同步队列中该结点的前驱结点waitStatus改为Node.SIGNAL，也就是-1，</strong>此时AQS的数据结构大概如下(额…..少画了个箭头，大家就当head结点是线程A结点的前驱结点就好)：<br><img src="https://img-blog.csdnimg.cn/78361e79df79425eb6549525931fb9df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>回到await()方法，当线程A的结点被加入同步队列中时，isOnSyncQueue()会返回true，跳出循环，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">while</span>(!isOnSyncQueue(node))&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>((interruptMode=checkInterruptWhileWaiting(node))!=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(acquireQueued(node,savedState)&amp;&amp;interruptMode!=THROW_IE)</span><br><span class="line">interruptMode=REINTERRUPT;</span><br><span class="line"><span class="keyword">if</span>(node.nextWaiter!=<span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// clean up if cancelled         </span></span><br><span class="line">unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span>(interruptMode!=<span class="number">0</span>)</span><br><span class="line">reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure>

<p>接着执行acquireQueued()方法，这里就不用多说了吧，尝试重新获取锁，如果获取锁失败继续会被挂起，直到另外线程释放锁才被唤醒。</p>
<p>所以，当线程B释放完锁后，线程A被唤醒，继续尝试获取锁，至此流程结束。</p>
<p>对于这整个通信过程，我们可以画一张流程图展示下：</p>
<p><img src="https://img-blog.csdnimg.cn/9edeeb8817454bfab069302e58a13ab5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说完了Condition的使用和底层运行机制，我们再来总结下它跟普通 wait/notify 的比较，一般这也是问的比较多的，Condition大概有以下两点优势：</p>
<p><strong>Condition 需要结合 Lock 进行控制，使用的时候要注意一定要对应的unlock()，可以对多个不同条件进行控制，只要new 多个 Condition对象就可以为多个线程控制通信</strong>，<code>wait/notify 只能和 synchronized 关键字一起使用，并且只能唤醒一个或者全部的等待队列；</code></p>
<p><strong>Condition 有类似于 await 的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是 park/unpark 的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁</strong>，但是 <code>wait/notify 会产生先唤醒再挂起的死锁。</code></p>
<p>无论是独占还是共享模式，或者结合是Condition工具使用，<strong>AQS本质上的同步功能都是通过对锁和队列中结点的操作来实现的</strong>，</p>
<h1 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h1><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将<strong>ReentrantLock跟常用的Synchronized进行比较</strong>，其特性如下：<br><img src="https://img-blog.csdnimg.cn/14cc40b6a6924b37b8a0e324ef99493f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbHVvLmNodW5oYWk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>下面通过伪代码，进行更加直观的比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object)&#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 4.可重入</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>throw Exception</span>&#123;</span><br><span class="line">	<span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">	ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">	<span class="comment">// 2.可用于代码块</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line">	<span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>,TimeUnit.MILLISECONDS))&#123;&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">// 4.手动释放锁</span></span><br><span class="line">	lock.unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-最基本的使用方式"><a href="#ReentrantLock-最基本的使用方式" class="headerlink" title="ReentrantLock 最基本的使用方式"></a>ReentrantLock 最基本的使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doSomething();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建ReentrantLock时默认使用非公平锁，效率高于公平锁，暂不讨论公平锁。</p>
<h3 id="ReentrantReadWriteLock的读锁的最基本的使用方式如下"><a href="#ReentrantReadWriteLock的读锁的最基本的使用方式如下" class="headerlink" title="ReentrantReadWriteLock的读锁的最基本的使用方式如下"></a>ReentrantReadWriteLock的读锁的最基本的使用方式如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		rwl.readLock().lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			read();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			rwl.readLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-synchronize"><a href="#2-synchronize" class="headerlink" title="2. synchronize"></a>2. synchronize</h1><p>synchronized可以保证方法或者代码块在运行时，<code>同一时刻只有一个方法可以进入到临界区</code>，同时它还可以<code>保证共享变量的内存可见性</code>。Synchronized主要有以下三个作用：<code>保证互斥性、保证可见性、保证顺序性</code>。</p>
<h1 id="synchronize与lock的区别"><a href="#synchronize与lock的区别" class="headerlink" title="synchronize与lock的区别"></a>synchronize与lock的区别</h1><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv8757383/">图文并茂：AQS 是怎么运行的？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chx9832/p/12574625.html">AQS 简介</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/da9d051dcc3d">Java技术之AQS详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></li>
</ol>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="link-muted mr-2" rel="tag" href="/tags/java%E9%94%81/">java锁</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/23/java/java-singleton/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">java 单例模式的写法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/23/linux/linux_cfs/"><span class="level-item">linux内核分析——CFS（完全公平调度算法）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "5c79ef203e33f303c806185625158496",
            repo: "luochunhai.github.io",
            owner: "luochunhai",
            clientID: "f9e12149d698e263599f",
            clientSecret: "5b76add2cdaa3ec47402cde6dc3bb5d913c7c48c",
            admin: ["luochunhai"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Luo Chunhai"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Luo Chunhai</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>四川·成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">70</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">27</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/luochunhai" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flink/"><span class="tag">flink</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gc/"><span class="tag">gc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java%E9%94%81/"><span class="tag">java锁</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jdk/"><span class="tag">jdk</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/opencv/"><span class="tag">opencv</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wsl/"><span class="tag">wsl</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zookeeper/"><span class="tag">zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tag">并发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8B%A6%E6%88%AA-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"><span class="tag">拦截/抓包工具</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91/"><span class="tag">树</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/centos/"><span class="level-start"><span class="level-item">centos</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/flink/"><span class="level-start"><span class="level-item">flink</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/gc/"><span class="level-start"><span class="level-item">gc</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/jdk/"><span class="level-start"><span class="level-item">jdk</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/jvm/"><span class="level-start"><span class="level-item">jvm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/netty/"><span class="level-start"><span class="level-item">netty</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/opencv/"><span class="level-start"><span class="level-item">opencv</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">spring</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/wsl/"><span class="level-start"><span class="level-item">wsl</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/zookeeper/"><span class="level-start"><span class="level-item">zookeeper</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-start"><span class="level-item">动态规划</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8B%A6%E6%88%AA-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">拦截/抓包工具</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%A0%91/"><span class="level-start"><span class="level-item">树</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%93%BE%E8%A1%A8/"><span class="level-start"><span class="level-item">链表</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#AQS-AbstractQueuedSynchronizer-抽象类的队列式同步器"><span class="level-left"><span class="level-item">1</span><span class="level-item">AQS (AbstractQueuedSynchronizer)  抽象类的队列式同步器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理概览"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">原理概览</span></span></a></li><li><a class="level is-mobile" href="#基础定义"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">基础定义</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#state"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">state</span></span></a></li><li><a class="level is-mobile" href="#AQS支持两种资源分享的方式："><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">AQS支持两种资源分享的方式：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#独占模式"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">独占模式</span></span></a></li><li><a class="level is-mobile" href="#共享模式"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">共享模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-Condition"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. Condition</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-ReentrantLock"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. ReentrantLock</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#ReentrantLock-最基本的使用方式"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">ReentrantLock 最基本的使用方式</span></span></a></li><li><a class="level is-mobile" href="#ReentrantReadWriteLock的读锁的最基本的使用方式如下"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">ReentrantReadWriteLock的读锁的最基本的使用方式如下</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#2-synchronize"><span class="level-left"><span class="level-item">4</span><span class="level-item">2. synchronize</span></span></a></li><li><a class="level is-mobile" href="#synchronize与lock的区别"><span class="level-left"><span class="level-item">5</span><span class="level-item">synchronize与lock的区别</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#参考文章"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">参考文章</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-03T00:48:44.000Z">2021-12-03</time></p><p class="title"><a href="/2021/12/03/nginx/nginx-suppport-http2/">nginx支持HTTP2的配置过程</a></p><p class="categories"><a href="/categories/nginx/">nginx</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-03T00:44:46.000Z">2021-12-03</time></p><p class="title"><a href="/2021/12/03/nginx/nginx-swagger-upstream/">Nginx转发，swagger误将upstream作为base url</a></p><p class="categories"><a href="/categories/nginx/">nginx</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-03T00:19:46.000Z">2021-12-03</time></p><p class="title"><a href="/2021/12/03/netty/netty-httpclient/">netty HttpClient</a></p><p class="categories"><a href="/categories/netty/">netty</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-25T08:27:11.000Z">2021-11-25</time></p><p class="title"><a href="/2021/11/25/algorithm_dynamic/dynamic-sum-equal-sub-set/">分割等和子集</a></p><p class="categories"><a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-25T03:32:06.000Z">2021-11-25</time></p><p class="title"><a href="/2021/11/25/algorithm_dynamic/algorithm-max-pub-sub-sequence/">求两个字符序列的最长公共字符子序列。</a></p><p class="categories"><a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Summer</a><p class="is-size-7"><span>&copy; 2021 Luo Chunhai</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>