{"pages":[{"title":"about","text":"AboutE-mail: 469608976@qq.com","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"hexo_guide","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start1hexo clean &amp;&amp; hexo g &amp;&amp; hexo server Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo clean &amp;&amp; hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/23/hexo-guide/"},{"title":"centos install jdk","text":"安装之前先查看一下有无系统自带jdk12345rpm -qa |grep javarpm -qa |grep jdkrpm -qa |grep gcj 如果有就使用批量卸载命令1rpm -qa | grep java | xargs rpm -e --nodeps 直接yum安装1.8.0版本openjdk1yum install java-1.8.0-openjdk* -y 查看版本1java -version 配置JAVA_HOMEA 定位JDK安装路径1. 终端输入：1which java 输出为： 1/usr/bin/java 2. 终端输入：1ls -lr /usr/bin/java 输出为： 1/usr/bin/java -&gt; 3. 终端输入1ls -lrt /etc/alternatives/java 输出： 1/etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-3.b13.el7_5.x86_64/jre/bin/java 至此，我们确定java的安装目录为： /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-3.b13.el7_5.x86_64 B 配置JAVA_HOME1. 打开配置环境变量的文件1vim /etc/profile 2. 添加以下配置：1234export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.181-3.b13.el7_5.x86_64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 1:wq保存退出。 3. 让配置生效1source /etc/profile 4. 测试配置结果1echo $JAVA_HOME","link":"/2021/09/27/centos/centos-jdk/"},{"title":"centos install jenkins","text":"prepare: install JDKinstall1wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo 1rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key 如果不能安装就到官网下载jenkis的rmp包，官网地址（http://pkg.jenkins-ci.org/redhat-stable/）一. 官方下载地址：https://jenkins.io/download/二. 镜像下载地址：http://mirrors.jenkins-ci.org/ 123 wget http://mirror.serverion.com/jenkins/redhat-stable/jenkins-2.235.1-1.1.noarch.rpmrpm -ivh jenkins-2.222.3-1.1.noarch.rpmyum install -y jenkins-2.222.3-1.1.noarch.rpm 1yum install -y jenkins 配置jenkis的端口 1vim /etc/sysconfig/jenkins 12找到修改端口号：JENKINS_PORT=&quot;8080&quot; 此端口不冲突可以不修改 modify mirror of update centerhttps://www.jianshu.com/p/fb1bff7a21a1 vim /var/lib/Jenkins/hudson.model.UpdateCenter.xml 12345678&lt;?xml version='1.1' encoding='UTF-8'?&gt;&lt;sites&gt; &lt;site&gt; &lt;id&gt;default&lt;/id&gt; &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/url&gt; &lt;/site&gt;&lt;/sites&gt; config jenkins jdkvim /etc/init.d/jenkins 1/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.252.b09-2.el7_8.x86_64/bin/java 启动jenkins 1systemctl start/stop/restart jenkins 开机启动 1systemctl enable jenkins.service su jenkins1su -s /bin/bash jenkins","link":"/2021/09/27/centos/centos-jinkins/"},{"title":"centos install git","text":"参考文章 https://blog.csdn.net/lqlqlq007/article/details/78983879 prepare12sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidocsudo yum install gcc perl-ExtUtils-MakeMaker 卸载系统自带的底版本git 123 git --versionsudo yum remove git install1cd /usr/local/src/ 1wget https://www.kernel.org/pub/software/scm/git/git-2.23.0.tar.xz 12tar -vxf git-2.23.0.tar.xzcd git-2.23.0 1sudo make prefix=/usr/local/git all 1sudo make prefix=/usr/local/git install 1sudo echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/profile 1source /etc/profile 12 git --versiongit version 2.15.1 如果是非root用户使用git，则需要配置下该用户下的环境变量 123 echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; ~/.bashrc source ~/.bashrcgit --version 生成SSH密钥1ssh-keygen -t rsa -C “469608976@qq.com” 添加密钥到GitHub 打开 Github，登录自己的账号后点击自己的头像-&gt;settings-&gt;SSH And GPG Keys-&gt;New SSH key 将本地 id_rsa.pub 中的内容粘贴到 Key 文本框中，随意输入一个 title(不要有中文)，点击 Add Key 即可 centos里测试验证1ssh git@github.com","link":"/2021/09/27/centos/centos-git/"},{"title":"centos install maven","text":"1、获取安装包并解压1234cd /usr/localwget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gztar -zxvf apache-maven-3.6.3-bin.tar.gz 2、配置环境变量，添加export1vim /etc/profile 12export MAVEN_HOME=/usr/local/mavenexport PATH=${MAVEN_HOME}/bin:${PATH} 1source /etc/profile 1mvn -v 12vim ~/.bash_profile JAVA_HOME 和 M2_HOME 都设置成自己文件的位置 1source ~/.bash_profile 3、添加阿里云镜像1vim $MAVEN_HOME/conf/settings.xm 添加以下镜像配置 123456789101112131415&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central-repository&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://central.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;","link":"/2021/09/27/centos/centos-maven/"},{"title":"centos install nginx","text":"prepare1sudo yum install -y gcc gcc-c++ 1sudo yum install -y gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel root 安装PCRE库123456cd /usr/local/wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gztar -zxvf pcre-8.33.tar.gzcd pcre-8.33./configuremake &amp;&amp; make install root 安装SSL库123456cd /usr/local/wget http://www.openssl.org/source/openssl-1.0.1j.tar.gztar -zxvf openssl-1.0.1j.tar.gzcd openssl-1.0.1j./configmake &amp;&amp; make install root 安装zlib库存123456 cd /usr/local/wget http://www.zlib.net/zlib-1.2.11.tar.gztar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11./configuremake &amp;&amp; make install set up nginx123456cd /home/kubemkdir downloadscd downloadswget https://nginx.org/download/nginx-1.16.1.tar.gztar xvf nginx-1.16.1.tar.gz cd /home/kube/downloads/nginx-1.16.1 1./configure --prefix=/home/kube/apps/nginx --user=kube --group=kube --error-log-path=/home/kube/logs/nginx/error.log --http-log-path=/home/kube/logs/nginx/access.log --with-http_ssl_module --with-openssl=/usr/local/openssl-1.0.1j --with-pcre=/usr/local/pcre-8.33 --with-zlib=/usr/local/zlib-1.2.11 --with-http_stub_status_module 12makemake install 1/home/kube/apps/nginx/sbin/nginx -V 3. login root1234567cd ~cd /home/kube/apps/nginx/sbinsudo chown root nginxsudo chmod +s nginxcd ~ kubesudo rm -rf nginx-1.16.1sudo rm nginx-1.16.1.tar.gz nginx.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465user root;worker_processes 2;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' # '$status $body_bytes_sent &quot;$http_referer&quot; ' # '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip off; # gzip_min_length 1k # gzip_comp_level 4 # gzip_types text/plain text/css application/json application/javascript server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://localhost:3000; } error_page 404 /404.html; location = /404.html { root html; } # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }} commands for the Nginx process123./nginx # Start./nginx -s reload ## Reload configure./nginx -s stop ## End","link":"/2021/09/27/centos/centos-nginx/"},{"title":"centos install mysql","text":"https://blog.csdn.net/qq_36582604/article/details/80526287","link":"/2021/09/27/centos/centos-mysql/"},{"title":"docker_cmd","text":"docker 基本命令1234567891011121314# -a :提交的镜像作者；# -c :使用Dockerfile指令来创建镜像；# -m :提交时的说明文字；# -p :在commit时，将容器暂停。docker commit -a &quot;author&quot; -m &quot;commit msg&quot; {commitId} {name}:{tag}#docker commit -a &quot;author&quot; -m &quot;commit msg&quot; {commitId} author/myubuntu:v1docker logindocker push author/myubuntu:v1docker tag {imageId} {name}:{tag}docker run --name nginx-text -p 9090:90 -d nginx","link":"/2021/09/27/docker/docker-cmd/"},{"title":"linux内核分析——CFS（完全公平调度算法）","text":"参考文章 CFS（完全公平调度算法） Linux进程调度策略（CFS调度）详解 [Linux][Power]CFS调度策略 Linux完全公平调度算法原理与实现 Linux进程调度：完全公平调度器CFS 基本介绍 在 2.5 版本之前，Linux 内核采用传统 UNIX 调度算法。 在内核 V2.5 中，调度程序进行了大改，采用了称为 O(1) 的调度算法，它的运行时间为常量，与系统内任务数量无关。 在内核 V2.6 的开发中，调度程序再次修改；在内核 V2.6.23 的发布中，完全公平调度程序（CFS）成为默认的 Linux 调度算法。 Linux 系统的调度基于调度类。每个类都有一个特定优先级。内核针对不同的调度类，采用不同的调度算法，以便满足系统与进程的需要。Linux 标准内核实现两个调度类：采用 CFS 调度算法的 默认调度类和实时调度类。 CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据友好值来计算的。友好值的范围从 -20 到 +19，数值较低的友好值表示较高的相对优先级。具有较低友好值的任务，与具有较高友好值的任务相比，会得到更高比例的处理器处理时间。默认友好值为 0。 友好一词源自如下想法：当一个任务增加了它的友好值，如从 0 至 +10，该任务通过降低优先级，进而对其他任务更加友好。 CFS 没有使用离散的时间片，而是采用目标延迟，这是每个可运行任务应当运行一次的时间间隔。根据目标延迟，按比例分配 CPU 时间。除了默认值和最小值外，随着系统内的活动任务数量超过了一定阈值，目标延迟可以增加。 CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（友好值为 0），虚拟运行时间与实际物理运行时间是相同的。 因此，如果一个默认优先级的任务运行 200ms，则它的虚拟运行时间也为 200ms。然而，如果一个较低优先级的任务运行 200ms，则它的虚拟运行时间将大于 200ms。同样，如果一个更高优先级的任务运行 200ms，则它的虚拟运行时间将小于 200ms。当决定下步运行哪个任务时，调度程序只需选择具有最小虚拟运行时间的任务。此外，一个更高优先级的任务如成为可运行，就会抢占低优先级任务。 下面分析一下 CFS 调度程序是如何工作的。假设有两个任务，它们具有相同的友好值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。 因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。 Linux 也实现了实时调度。采用 SCHED_FIFO 或 SCHED_RR 实时策略来调度的任何任务，与普通（非实时的）任务相比，具有更高的优先级。 Linux 采用两个单独的优先级范围，一个用于实时任务，另一个用于正常任务。实时任务分配的静态优先级为 0〜99，而正常任务分配的优先级为 100〜139。 这两个值域合并成为一个全局的优先级方案，其中较低数值表明较高的优先级。正常任务，根据它们的友好值，分配一个优先级；这里 -20 的友好值映射到优先级 100，而 +19 的友好 1.1 CFS原理cfs定义了一种新的模型，它给cfs_rq（cfs的run queue）中的每一个进程安排一个虚拟时钟，vruntime。如果一个进程得以执行，随着时间的增长（也就是一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变。而调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。 1.2 CFS基本设计思路CFS思路很简单，就是根据各个进程的权重分配运行时间(权重怎么来的后面再说)。 进程的运行时间计算公式为: 分配给进程的运行时间 = 调度周期 * 进程权重 / 所有进程权重之和 (公式1) 调度周期: 将所有处于TASK_RUNNING态进程都调度一遍的时间,差不多相当于O(1)调度算法中运行队列和过期队列切换一次的时间。 举个例子，比如只有两个进程A, B，权重分别为1和2，调度周期设为30ms，那么分配给A的CPU时间为:30ms * (1/(1+2)) = 10ms；而B的CPU时间为：30ms * (2/(1+2)) = 20ms。那么在这30ms中A将运行10ms，B将运行20ms。 公平怎么体现呢？它们的运行时间并不一样阿？其实公平是体现在另外一个量上面，叫做**virtual runtime(vruntime)**，它记录着进程已经运行的时间，但是并不是直接记录，而是要根据进程的权重将运行时间放大或者缩小一个比例。我们来看下从实际运行时间到vruntime的换算公式 vruntime = 实际运行时间 * 1024 / 进程权重 。 (公式2) 为了不把大家搞晕，这里我直接写1024，实际上它等于nice为0的进程的权重，代码中是NICE_0_LOAD。也就是说，所有进程都以nice为0的进程的权重1024作为基准，计算自己的vruntime增加速度。 还以上面AB两个进程为例，B的权重是A的2倍，那么B的vruntime增加速度只有A的一半。 现在我们把公式2中的实际运行时间用公式1来替换，可以得到这么一个结果： vruntime = (调度周期 * 进程权重 / 所有进程总权重) * 1024 / 进程权重 = 调度周期 * 1024 / 所有进程总权重 看出什么眉目没有？没错，虽然进程的权重不同，但是它们的 vruntime增长速度应该是一样的 ，与权重无关。好，既然所有进程的vruntime增长速度宏观上看应该是同时推进的， 那么就可以用这个vruntime来选择运行的进程，谁的vruntime值较小就说明它以前占用cpu的时间较短，受到了“不公平”对待，因此下一个运行进程就是它。这样既能公平选择进程，又能保证高优先级进程获得较多的运行时间。这就是CFS的主要思想了。 或者可以这么理解：CFS的思想就是让每个调度实体（没有组调度的情形下就是进程，以后就说进程了）的vruntime互相追赶，而每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样就能获得更多的cpu执行时间。 再补充一下权重的来源，权重跟进程nice值之间有一一对应的关系，可以通过全局数组prio_to_weight来转换，nice值越大，权重越低。 1.3 CFS数据结构介绍代码之前先介绍一下CFS相关的结构第一个是调度实体sched_entity，它代表一个调度单位，在组调度关闭的时候可以把他等同为进程。每一个task_struct中都有一个sched_entity，进程的vruntime和权重都保存在这个结构中。那么所有的sched_entity怎么组织在一起呢？红黑树。所有的sched_entity以vruntime为key(实际上是以vruntime - min_vruntime为key，是为了防止溢出， 反正结果是一样的)插入到红黑树中，同时缓存树的最左侧节点，也就是vruntime最小的节点，这样可以迅速选中vruntime最小的进程。注意只有等待CPU的就绪态进程在这棵树上，睡眠进程和正在运行的进程都不在树上。 红黑树： 红黑树是自平衡的，没有路径比其它任何路径长两倍以上。树上运行按O(log n)时间发生（n是树中节点的数量），可以快速高效的插入或者删除任务。 任务存储在以时间为顺序的红黑树中（由 sched_entity 对象表示），对处理器需求最多的任务 （最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧。为了公平，调度器然后选取红黑树最左端的节点调度为下一个以便保持公平性。任务通过将其运行时间添加到虚拟运行时，说明其占用 CPU 的时间，然后如果可运行，再插回到树中。这样，树左侧的任务就被给予时间运行了，树的内容从右侧迁移到左侧以保持公平。 因此，每个可运行的任务都会追赶其他任务以维持整个可运行任务集合的执行平衡。 1.4 Vruntime溢出问题之前说过红黑树中实际的作为key的不是vruntime而是vruntime - min_vruntime。min_vruntime是当前红黑树中最小的key。这是为什么呢，我们先看看vruntime的类型，是usigned long类型的，再看看key的类型，是signed long类型的，因为进程的虚拟时间是一个递增的正值，因此它不会是负数，但是它有它的上限，就是unsigned long所能表示的最大值，如果溢出了，那么它就会从0开始回滚，如果这样的话，结果会怎样？结果很严重啊，就是说会本末倒置的，比如以下例子，以unsigned char说明问题： 123unsigned char a = 251, b = 254;b += 5;//到此判断a和b的大小 看看上面的例子，b回滚了，导致a远远大于b，其实真正的结果应该是b比a大8，怎么做到真正的结果呢？改为以下： 12345unsigned char a = 251, b = 254;b += 5;signed char c = a - 250,d = b - 250;//到此判断c和d的大小 结果正确了，要的就是这个效果，可是进程的vruntime怎么用unsigned long类型而不处理溢出问题呢？因为这个vruntime的作用就是推进虚拟时钟，并没有别的用处，它可以不在乎，然而在计算红黑树的key的时候就不能不在乎了，于是减去一个最小的vruntime将所有进程的key围绕在最小vruntime的周围，这样更加容易追踪。运行队列的min_vruntime的作用就是处理溢出问题的。 1.5 组调度引入组调度是为了实现做一件事的一组进程与做另一件事的另一组进程的隔离。每件“事情”各自有自己的权重，而不管它需要使用多少进程来完成。在cfs中，task_group和进程是同等对待的，task_group的优先级也由用户来控制（通过cgroup文件cpu.shares）。实现上，task_group和进程都被抽象成schedule_entity（调度实体，以下简称se），上面说到的vruntime、load、等这些东西都被封装在se里面。而task_group除了有se之外，还有cfs_rq。属于这个task_group的进程就被装在它的cfs_rq中（“组”不仅是一个被调度的实体，也是一个容器）。组调度引入以后，一系列task_group的cfs_rq组成了一个树型结构。树根是cpu所对应的cfs_rq（也就是root group的cfs_rq）、树的中间节点是各个task_group的cfs_rq、 叶子节点是各个进程。在一个task_group的两头，是两个不同的世界，就像《盗梦空间》里不同层次的梦境一样。 1.6 CFS小结CFS还有一个重要特点，即调度粒度小。CFS之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而CFS则在每次tick都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。","link":"/2021/09/23/linux/linux_cfs/"},{"title":"git常用命令","text":"1. 常用命令git tag12345678910111213141516# create taggit tag test_tag# delete taggit tag -d test_taggit push origin :refs/tags/test_tag# push taggit push origin test_taggit push origin --tags# show taggit show test_tag# 基于某个commit id create taggit tag -a test_tag {commitId} git 版本回退123456789101112131415161718# git log 命令可以显示所有提交过的版本信息# --pretty=oneline，只会显示版本号和提交时的备注信息git log --pretty=oneline# git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）git reflog # git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可；# 撤销该commit，但是又不能撤销该提交包含的更改，使用git reset --soft# 可见commit取消了，代码更改并没有取消git reset --soft {commitId}# git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉；git reset --hard {commitId}git push origin HEAD --force# 用某个commit 创建一个分支git branch {branch_name} {commitId} 2. git 安装配置1、检查git是否已经安装，输入git version命令即可，如果没有显示版本号表示没有安装git2、安装git ubuntusudo apt-get install git 3、配置git全局环境12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot; 4、生成ssh密钥ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;会在用户目录~/.ssh/下建立相应的密钥文件。 5、创建完公钥后，需要上传。使用命令cd ~/.ssh进入~/.ssh文件夹，输入cat id_rsa.pub打开id_rsa.pub文件，复制其中所有内容。接着访问git网页，点击SSH公钥，标题栏可以随意输入，公钥栏把刚才复制的内容粘贴进去。 创建一个空的目录，初始化git仓库，添加远程仓库做测试 6、测试连接ssh -T git@github.com 7、git使用命令123456789git clone 项目地址 拉项目git pull 拉代码git push 提交到仓库git init指令初始化一个git仓库git add .添加文件git commit -m &quot;注释&quot;提交至仓库。git remote add origin https://git.oschina.net/你的用户名/项目名.git，git push origin master即可完成推送git checkout master 切换到master分支","link":"/2021/09/27/git/git-cmd/"},{"title":"Linux 组调度","text":"参考文章 Linux 组调度浅析 Linux内核之实时进程调度和组调度","link":"/2021/09/24/linux/linux-cgroup/"},{"title":"wsl常用命令","text":"参考文章 https://docs.microsoft.com/zh-cn/windows/wsl/reference 设置默认版本wsl --set-default-version 2 检查分配给每个已安装的 Linux 分发版的 WSL 版本wsl -l -vwsl --list --verbose 将分发版设置为受某一 WSL 版本支持wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt; 运行/停止Ubuntu子系统wsl -l 列出了系统中安装的子系统名称，可以是一个或多个，本文中的子系统名称是Ubuntu-18.04-20190707，接下来针对这个默认子系统进行操作： 运行子系统wsl --distribution Ubuntu-18.04-20190707或者wsl -d Ubuntu-18.04-20190707 查看运行中的子系统-l --running12 适用于 Linux 的 Windows 子系统:Ubuntu-18.04-20190707 (默认) 停止子系统wsl -t Ubuntu-18.04-20190707或者wsl --terminate Ubuntu-18.04-20190707 备份/删除/还原子系统备份子系统非常简单，但一定要先停止子系统之后再备份wsl --export Ubuntu-18.04-20190707 c:\\temp\\Ubuntu-18.04-20190707.tar等待完成即可。备份成功后，子系统会被打包成命令中指定的tar文件。 删除子系统也是一个命令即可：wsl --unregister Ubuntu-18.04-20190707这样WSL子系统就从Windows中删除的干干净净了。 还原子系统删除了没关系，刚才做了备份，也是一个命令还原：wsl --import Ubuntu-18.04-20190707 c:\\WSL c:\\temp\\Ubuntu-18.04-20190707.tar这里注意指定还原的路径。成功后，子系统又回来了，可以用wsl -l确认一下。 用于运行 Linux 命令的参数 不带参数 如果未提供命令行，wsl.exe 将启动默认 shell。 –exec, -e 执行指定的命令，但不使用默认的 Linux shell。 按原样传递剩余的命令行。 上述命令也接受以下选项： –distribution, -d 运行指定的分发版。 –user, -u 以指定用户的身份运行。 用于管理适用于 Linux 的 Windows 子系统的参数 –export 将分发版导出到 tar 文件。 在标准输出中，文件名可以是 -。 –import 导入指定的 tar 文件作为新的分发版。 在标准输入中，文件名可以是 -。 –list、-l [选项] 列出分发版。 选项： –all 列出所有分发版，包括当前正在安装或卸载的分发版。 –verbose, -v 显示命令的附加信息或展开的详细信息。 –running 仅列出当前正在运行的分发版。 –set-default, -s 将分发版设置为默认值。 –terminate, -t 终止指定的分发版。 –unregister 注销分发版。 –help 显示用法信息。","link":"/2021/09/27/wsl/wsl-cmd/"},{"title":"wsl install centos","text":"参考文章 https://zhuanlan.zhihu.com/p/347461016 install centosWindows的应用商店中有一些不错的linux发行版，包括很多同学都很喜欢的ubuntu，但是个人比较熟悉使用centos，而应用商店中的centos是要收费的，不过好在github上面有CENTOS官方开源的安装包，我们这里使用github上的安装包进行安装。 如果使用应用商店中的发行版直接点击安装即可。随后便可以跳过下面的centos的安装部分。 首先我们去centos的GitHub页面下载对应的安装包：https://github.com/CentOS/sig-cloud-instance-images/blob/CentOS-8-x86_64/docker/centos-8-x86_64.tar.xz 接着我们以管理员身份打开一个powershell窗口： 1234# 安装 ChocolateySet-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))# 安装 LxRunOfflinechoco install lxrunoffline 注意这里安装完成之后需要重启powershell来进行下一步的安装 LxRunOffline.exe install -n centos -d D:\\wsl\\centos -f D:\\wsl\\centos-8-x86_64.tar.xz 12345LxRunOffline install -n 自定义系统名称 -d 安装目录路径 -f tar.xz安装包路径# 注意windows系统命令行中的文件路径和linux系统差别很大# 比如我这里的安装命令就是LxRunOffline.exe install -n centos -d D:/centos -f .\\centos-7-x86_64-docker.tar.xz# 将centos安装到D盘的centos文件夹下，并且命名为centos 接下来就可以使用下述两种方式尝试启动 12LxRunOffline run -n 自定义系统名称wsl -d 自定义系统名称 升级centos为wsl2123456# 列出已经安装的wsl的信息wsl -l -v# 将对应的wsl设为wsl2，注意&lt;Distro&gt;要和上面查询到的信息一致wsl --set-version &lt;Distro&gt; 2# 设置默认使用的发行版wsl -s &lt;Distro&gt;","link":"/2021/09/27/wsl/wsl-centos/"},{"title":"linux_cmd","text":"拷贝文件 SCP123456# 拷贝本地文件到远程scp xxx.txt root@{ip / hosts}:/root# 拷贝远程文件到本地scp root@{ip / hosts}:/rootxxx.txt /root top 命令1234567891011# d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。# p:通过指定监控进程ID来仅仅监控某个进程的状态。# q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。# S：指定累计模式。# s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。# i：使top不显示任何闲置或者僵死进程。# c:显示整个命令行而不只是显示命令名。top -H -b -d 1 -n 200 &gt; top.txt# -p : 通过监控进程ID来仅仅监控某个进程的状态top -p {pid}# -i ： 不显示任何闲置或僵死的进程 free12free -mfree -h jmap123# 查看堆内存使用情况jmap -heap {pid} netstat 123456789101112131415# -a (all)显示所有选项，默认不显示LISTEN相关# -t (tcp)仅显示tcp相关选项# -u (udp)仅显示udp相关选项# -n 拒绝显示别名，能显示数字的全部转化成数字。# -l 仅列出有在 Listen (监听) 的服務状态# -p 显示建立相关链接的程序名# -r 显示路由信息，路由表# -e 显示扩展信息，例如uid等# -s 按各个协议进行统计# -c 每隔一个固定时间，执行该netstat命令。netstat -ltnpnetstat -ano | findstr &quot;6379&quot; cat 日志查询123456789# 1. 查询日志中关键字cat -n summer.log | grep &quot;关键字&quot; | wc -l # 2.查询某段时间内的日志sed -n '/start_time/,/end_time/p' summer.log|grep &quot;key words&quot;# set -n '/2021-03-15 01:29:17/,/2021-03-15 02:29:17/p' summer.logwc -l # 统计行数wc -c # 统计字节数wc -l # 统计字数 sed123# sed -n '/start time/,/end time/p' aaa.log | grep &quot;keyword&quot;sed -n '/2021-03-16 01:29:17/,/2021-03-16 02:29:17/p' aa.log | grep &quot;keyword&quot; grep 查看大日志文件123456789101112# A -&gt; After# B -&gt; Before# C -&gt; Contextgrep -A5 'Time: 210607 15:[45-59]' slow3306_9110.log# 匹配多个关键字（且）# 管道符连接 多个条件 实现关键字 且关系 匹配：grep -A5 'Time: 210607 15:[45-59]' slow3306_9110.log | grep 'Query_time: (\\d[2-5])'# 同一行同时满足两个条件（Time、Query_time）才能够匹配。# grep -E 匹配多个关键字（或）grep -E &quot;word1|word2|word3&quot; file.txt# 匹配文件中 同一行包含 word1、word2、word3 之一 tar 压缩、解压123456789# -c: 打包 把 /conf/xxx.* 打包到 xxx.tar.gztar czvf xxx.tar.gz /conf/xxx.*# -x: 解压缩 tar xzvf xxx.tar.gz# -z: gzip 压缩格式# -v: 显示打包guoch# -f：显示打包名称 linux 重启hosts12sudo /etc/init.d/network restart linux 文件属性、权限123456789101112131415# 修改文件属主、组chown -R lch.lch /usr/localchgrp -R lch /usr/local# 修改 u g o 权限chomd g=rwx 1.txtchomd u=rwx 1.txtchomd o=rwx 1.txt# 增加shell 执行权限chmod +x xxx.sh# 修改用户的组usermod -g root lchuserdel -R lch add user123456adduser '用户名'passwd '用户名'chmod -v u+w /etc/sudoersvim /etc/sudoers 找到Allow root to run any commands anywhere之后添加一行 1'用户名' ALL=(ALL) ALL 如需新用户使用sudo时不用输密码，把最后一个ALL改为NOPASSWD:ALL即可 firewall1sudo systemctl status firewalld 1sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent 1sudo firewall-cmd --reload 1sudo firewall-cmd --list-all 1234567891011121314151617181920212223启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed配置firewalld-cmd查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic ab testapach AB test1234# -n: 执行的请求数# -c: 并发数ab -c10 -n100 http://www.baidu.com/","link":"/2021/09/27/linux/linux-cmd/"},{"title":"JVM内存结构","text":"参考文章 https://juejin.cn/post/6970606107442020360 https://juejin.cn/post/6844903592374042637 https://www.cnblogs.com/ityouknow/p/5610232.html JVMJVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area) 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。 JVM 内存结构 程序计数器 线程私有 程序计数器（Program Counter Register）是一块较小的内存空间，**它的作用可以看做是当前线程所执行的字节码的行号指示器**。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。** 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 异常情况此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 JVM栈/方法栈线程私有 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，**它的生命周期与线程相同。**虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 控制参数 1-Xss控制每个线程栈的大小 异常情况 在Java虚拟机规范中，对这个区域规定了两种异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈）， 当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈线程私有 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而**本地方法栈则是为虚拟机使用到的Native方法服务。**虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。 控制参数在Sun JDK中本地方法栈和方法栈是同一个，因此也可以用-Xss控制每个线程的大小。 1-Xss控制每个线程栈的大小 异常情况与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆线程共享对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。所有新生成的对象首先都是放在新生代的。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到老年代的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。 控制参数 1234-Xms设置堆的最小空间大小-Xmx设置堆的最大空间大小-XX:NewSize设置新生代最小空间大小-XX:MaxNewSize设置新生代最小空间大小 垃圾回收此区域是垃圾回收的主要操作区域。 异常情况如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 方法区线程共享 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。 控制参数12-XX:PermSize 设置最小空间 -XX:MaxPermSize 设置最大空间 垃圾回收 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。 异常情况根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 HotSpot中方法区的变化 jdk版本 区别 jdk1.6及之前 有永久代，静态变量存放在永久代上 jdk1.7 有永久代，但已经逐步去“永久代”，字符串常量池、静态变量移除，保存着堆中 jdk1.8及之后 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中 运行时常量池 运行时常量池是在方法区的一部分； Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放； Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但是对于运行时常量池，《Java虚拟机规范》没有做任何细节的要求，不用的提供上实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中；运行时常量池相对于Class文件常量池的另外一个重要特征就是具备动态性，Java语言并不要求常量一定只有在编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 永久代和元空间java7及以前版本JVM内存结构图 堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。但在物理上来说，它们又是连续的一块内存。 也就是说，方法区和前面讲到的Eden和老年代是连续的。 永久代（PermGen）对于习惯了在HotSpot虚拟机上开发、部署的程序员来说，很多都愿意将方法区称作永久代。本质上来讲两者并不等价，仅因为Hotspot将GC分代扩展至方法区，或者说使用永久代来实现方法区。在其他虚拟机上是没有永久代的概念的。也就是说方法区是规范，永久代是Hotspot针对该规范进行的实现。 理解上面的概念之后，我们对Java7及以前版本的堆和方法区的构造再进行一下变动。 对Java7及以前版本的Hotspot中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。 但在Java7中永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了。比如，符号引用(Symbols)转移到了Native Memory；字符串常量池(interned strings)转移到了Java Heap；类的静态变量(class statics)转移到了Java Heap。然后，在Java8中，时代变了，Hotspot取消了永久代。永久代真的成了永久的记忆。永久代的参数-XX:PermSize和-XX：MaxPermSize也随之失效。 元空间（Metaspace）对于Java8，HotSpots取消了永久代，那么是不是就没有方法区了呢？当然不是，方法区只是一个规范，只不过它的实现变了。在Java8中，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。 本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。 针对Java8的调整，我们再次对内存结构图进行调整。 元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中java.lang.OutOfMemoryError: PermGen space这种错误。默认情况下元空间是可以无限使用本地内存的，但为了不让它如此膨胀，JVM同样提供了参数来限制它使用的使用。 -XX:MetaspaceSize class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。 -XX：MaxMetaspaceSize 可以为class metadata分配的最大空间。默认是没有限制的。 -XX：MinMetaspaceFreeRatio 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。 -XX:MaxMetaspaceFreeRatio 在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。 面试官 | JVM 为什么使用元空间替换了永久代？ 表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。 当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。 更深层的原因还是要合并HotSpot和JRockit的代码，JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障。 直接内存在JVM的内存模型，里面并不包含直接内存，也就是说这块内存区域并不是JVM运行时数据区的一部分，但它却会被频繁的使用，原因是NIO这个包；NIO（New input/output）是JDK1.4中新加入的类，引入了一种基于通道（channel）和缓冲区（buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过堆上的DirectByteBuffer对象对这块内存进行引用和操作。 可以看出，直接内存的大小并不受到java堆大小的限制，甚至不受到JVM进程内存大小的限制。它只受限于本机总内存（RAM及SWAP区或者分页文件）大小以及处理器寻址空间的限制（最常见的就是32位/64位CPU的最大寻址空间限制不同）。 总结JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间, 默认情况下年轻代按照8:1:1的比例来分配； 方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。 在通过一张图来了解如何通过参数来控制各区域的内存大小 1234567-Xms设置堆的最小空间大小-Xmx设置堆的最大空间大小-XX:NewSize设置新生代最小空间大小-XX:MaxNewSize设置新生代最大空间大小-XX:PermSize设置永久代最小空间大小-XX:MaxPermSize设置永久代最大空间大小-Xss设置每个线程的堆栈大小","link":"/2021/09/28/java/java-jvm-memory/"},{"title":"Java内存模型","text":"Java 内存模型对JVM内存结构的描述中，我们知道了堆和方法区是线程共享的。而局部变量，方法定义参数和异常处理器参数就不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。 Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 Java内存模型的抽象示意图如下： 从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤： 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 下面通过示意图来说明这两个步骤： 如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。 从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。 重排序在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序： 上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。 JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 处理器重排序与内存屏障指令现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！为了具体说明，请看下面示例： 1234Processor A Processor Ba = 1; //A1 x = b; //A2 b = 2; //B1 y = a; //B2 初始状态：a = b = 0 处理器允许执行后得到结果：x = y = 0假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示： 这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。 从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。 这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。 happens-before从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 **提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性**。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下： 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。 注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。 happens-before 与 JMM 的关系如下图所示： 如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。 参考文章 https://zhuanlan.zhihu.com/p/38348646 https://www.infoq.cn/article/java-memory-model-1/","link":"/2021/09/28/java/java-jmm/"},{"title":"常见内存溢出错误","text":"Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space 原因：对象不能被分配到堆内存中。 Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space 原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库。 Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit 原因：创建的数组大于堆内存的空间。 Exception in thread “main”: java.lang.OutOfMemoryError: request bytes for . Out of swap space? 原因：分配本地分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。 Exception in thread “main”: java.lang.OutOfMemoryError: （Native method） 原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现。 Troubleshooting Guide for HotSpot VM”, Chapter 3 on “Troubleshooting on memory leaks","link":"/2021/09/28/java/java-oom/"},{"title":"wsl install ubuntu","text":"参考文章 https://blog.csdn.net/weixin_45883933/article/details/106085184 安装前配置ref: 适用于 Linux 的 Windows 子系统安装指南 (Windows 10) 1. 启用 Windows 功能搜索并打开“启用或关闭 Windows 功能”，然后选择“适用于Linux的Windows子系统”复选框。 在windows功能中重新勾选hyper-v然后开启hyper-v模式在管理员powershell中执行 1bcdedit /set hypervisorlaunchtype auto 如果禁用了组策略里面的Device Guard虚拟化安全设置，需要打开组策略管理，本地计算机策略 &gt; 计算机配置 &gt; 管理模板&gt;系统 &gt; Device Guard打开 基于虚拟化的安全设置为“已开启”或者“未设置”随后重新开启wsl2，若不行，重启计算机。 启用虚拟机平台可选组件在 powerShell 中以管理员身份运行下面命令 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 运行完成之后，请重启电脑完成安装. 设置WSL发行版如果想要将默认的WSL发行版设置成 WSL 2，在 powerShell 中使用下面命令 wsl --set-default-version 2如果想要设置某一个发行版为WSL2，在 powerShell 中使用下面命令，将 换成你想要设置的发行版即可，例如 Ubuntu-18.04 wsl --set-version &lt;Distro&gt; 2 wsl --set-version Ubuntu-20.04 2验证使用的WSL版本 wsl -l -v 下载安装 Ubuntu-20.04 (Windows 应用商店里)更新包目录，并使用分发版的首选包管理器升级已安装的包sudo apt update &amp;&amp; sudo apt upgrade Windows不会自动更新或升级Linux发行版：Linux用户经常意外自行控制此任务。123456789101112131415161718192021222324252627ubuntu@kylin：〜$ wslfetch ./+o+- Windows 10 Linux Subsystem yyyyy. 'yyyyyy+ root@kylin .;//+/h yyyyyyo BUILD: 19624 .++ .:/++++++/-.`sss/` BRANCH: rs_prerelease .:++o: `\\++++++++/:---:/- RELEASE: Ubuntu 20.04 LTS o:+o+:++. `````'-/ooo+++++\\ KERNEL: Linux 4.19.104-microsoft-standard .:+o:+o/. `+sssooo+\\ UPTIME: 0d 0h 2m .++/+ +oo+o:` \\sssooo; /+++//+: oo+o \\+/+o+++ o++o ydddhh+ .++.o+ +oo+:` /dddhhh; .+.o+oo:. oddhhhh+ \\+.++o+o` -,,,,.:ohdhhhhh+ `:o+++ ohhhhhhhhyo++os: .o: .syhhhhhhh'.oo++o. /osyyyyyyy.oooo+++\\ `````+oo+++o:/ `oo++'`root@kylin:~# lsb_release -a | lolcatNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 20.04 LTSRelease: 20.04Codename: focalubuntu @ kylin:/ $ sudo apt install lolcat sudo apt install lolcat lsb_release -a | lolcat wsl ubuntu config1 修改 默认的源 (更换国内源)cp /etc/apt/sources.list /etc/apt/sourses.list.bak 更换默认源为阿里源, 使用 sudo vim /etc/apt/sources.list 命令编辑，删除原来的内容，添加下面的阿里源信息 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更换源之后，使用下面的命令更新一下 12sudo apt-get updatesudo apt-get upgrade 2.ssh 连接 配置在WSL Ubuntu系统中安装ssh server当对Linux实现文件操作时，使用WinScp更为方便。因此需要使用ssh远程登陆 安装ssh serversudo apt-get install openssh-server 配置ssh使用 cp 命令将 SSH 相关配置备份sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak 使用 vim 编辑 sshd_config 文件 sudo vim /etc/ssh/sshd_config调整一下设置： 12345Port 22ListenAddress 0.0.0.0PermitRootLogin yesStrictModes yesPasswordAuthentication yes 12345678910111213141516171819root@summer:/# service ssh status * sshd is not runningroot@summer:/# service ssh start * Starting OpenBSD Secure Shell server sshd sshd: no hostkeys available -- exiting.root@summer:/# sshd -Tsshd: no hostkeys available -- exiting.root@summer:/# ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyroot@summer:/# ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyroot@summer:/etc/ssh# sshd -Troot@summer:/etc/ssh# service ssh start * Starting OpenBSD Secure Shell server sshd [ OK ] ＃Ubuntu的防火墙状态检测，防火墙可能限制SSH端口22root@summer:~# service ufw status * Firewall is not running... [fail]root@kylin:~# 重启ssh service 1sudo service ssh restart sshd: no hostkeys available — exiting在开启SSHD服务时报错.sshd re-exec requires execution with an absolute path用绝对路径启动,也报错如下:Could not load host key: /etc/ssh/ssh_host_keyCould not load host key: /etc/ssh/ssh_host_rsa_keyCould not load host key: /etc/ssh/ssh_host_dsa_keyDisabling protocol version 1. Could not load host keyDisabling protocol version 2. Could not load host keysshd: no hostkeys available — exiting解决过程: 123ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key/usr/sbin/sshd 如果上述两个文件存在，仍然出现这个错误，那么试试 chmod 600 上述两个文件。之后应该可以解决。 ssh login登陆 SSH使用 SSH 指令登陆 ssh root@127.0.0.1 -p 22 运行/停止Ubuntu子系统wsl -l 列出了系统中安装的子系统名称，可以是一个或多个，本文中的子系统名称是Ubuntu-18.04-20190707，接下来针对这个默认子系统进行操作： 运行子系统wsl --distribution Ubuntu-18.04-20190707或者wsl -d Ubuntu-18.04-20190707 查看运行中的子系统-l --running12 适用于 Linux 的 Windows 子系统:Ubuntu-18.04-20190707 (默认) 停止子系统wsl -t Ubuntu-18.04-20190707或者wsl --terminate Ubuntu-18.04-20190707 备份/删除/还原子系统备份子系统非常简单，但一定要先停止子系统之后再备份wsl --export Ubuntu-18.04-20190707 c:\\temp\\Ubuntu-18.04-20190707.tar等待完成即可。备份成功后，子系统会被打包成命令中指定的tar文件。 删除子系统也是一个命令即可：wsl --unregister Ubuntu-18.04-20190707这样WSL子系统就从Windows中删除的干干净净了。 还原子系统删除了没关系，刚才做了备份，也是一个命令还原：wsl --import Ubuntu-18.04-20190707 c:\\WSL c:\\temp\\Ubuntu-18.04-20190707.tar这里注意指定还原的路径。成功后，子系统又回来了，可以用wsl -l确认一下。 install docker-engines under ubuntu.refer to: https://docs.docker.com/engine/install/ubuntu/ 12345#启动docker sudo service docker startservice --status-allsudo service docker start #WSL2下能使用 systemctl, 参考：https://www.cnblogs.com/a5idc/p/13752839.htmlsudo usermod -aG docker {$USER}，$user是linux os你创建的用户，参考：https://docs.docker.com/engine/install/linux-postinstall/docker run hello-world #检查是否安装成功 install docker-compose under ubuntu.参考： https://docs.docker.com/compose/install/ 1sudo chmod +x /usr/local/bin/docker-compose 在ubuntu下git checkout docker-compose目录，运行mysql等服务。在windows下，可直接使用localhost连接123docker-compose up #启动并运行docker-compose up -d #在后台运行docker-compose down apt-get install telnetapt-get -y install netcat-traditional","link":"/2021/09/27/wsl/wsl-ubuntu/"},{"title":"java 单例模式的写法","text":"饱汉模式饱汉是变种最多的单例模式。我们从饱汉出发，通过其变种逐渐了解实现单例模式时需要关注的问题。 基础的饱汉饱汉，即已经吃饱，不着急再吃，饿的时候再吃。所以他就先不初始化单例，等第一次使用的时候再初始化，即·“懒加载”·。 12345678910111213// 饱汉// UnThreadSafepublic class Singleton1 { private static Singleton1 singleton = null; private Singleton1() { } public static Singleton1 getInstance() { if (singleton == null) { singleton = new Singleton1(); } return singleton; }} 饱汉模式的核心就是懒加载。好处是更启动 速度快、节省资源，一直到实例被第一次访问，才需要初始化单例；小坏处是写起来麻烦，大坏处是线程不安全，if语句存在竞态条件。 写起来麻烦不是大问题，可读性好啊。因此，单线程环境下，基础饱汉是最好。但多线程环境下，基础饱汉就彻底不可用了。下面的几种变种都在试图解决基础饱汉线程不安全的问题。 饱汉 - 变种 1最粗暴的犯法是用synchronized关键字修饰getInstance()方法，这样能达到绝对的线程安全。 12345678910111213// 饱汉// ThreadSafepublic class Singleton1_1 { private static Singleton1_1 singleton = null; private Singleton1_1() { } public synchronized static Singleton1_1 getInstance() { if (singleton == null) { singleton = new Singleton1_1(); } return singleton; }} 变种1的好处是写起来简单，且绝对线程安全；坏处是并发性能极差，事实上完全退化到了串行。单例只需要初始化一次，但就算初始化以后，synchronized的锁也无法避开，从而getInstance()完全变成了串行操作。性能不敏感的场景建议使用。 饱汉 - 变种 2变种2是“臭名昭著”的DCL 1.0。 针对变种1中单例初始化后锁仍然无法避开的问题，变种2在变种1的外层又套了一层check，加上synchronized内层的check，即所谓“双重检查锁”（Double Check Lock，简称DCL）。 123456789101112131415161718192021// 饱汉// UnThreadSafepublic class Singleton1_2 { private static Singleton1_2 singleton = null; public int f1 = 1; // 触发部分初始化问题 public int f2 = 2; private Singleton1_2() { } public static Singleton1_2 getInstance() { // may get half object if (singleton == null) { synchronized (Singleton1_2.class) { if (singleton == null) { singleton = new Singleton1_2(); } } } return singleton; }} 变种2的核心是DCL，看起来变种2似乎已经达到了理想的效果：懒加载+线程安全。可惜的是，正如注释中所说，DCL仍然是线程不安全的，由于指令重排序，你可能会得到“半个对象”，即”部分初始化“问题。 参考：volatile关键字的作用、原理 饱汉 - 变种 3变种3专门针对变种2，可谓DCL 2.0。 针对变种3的“半个对象”问题，变种3在instance上增加了volatile关键字，原理见上述参考。 123456789101112131415161718192021// 饱汉// ThreadSafepublic class Singleton1_3 { private static volatile Singleton1_3 singleton = null; public int f1 = 1; // 触发部分初始化问题 public int f2 = 2; private Singleton1_3() { } public static Singleton1_3 getInstance() { if (singleton == null) { synchronized (Singleton1_3.class) { // must be a complete instance if (singleton == null) { singleton = new Singleton1_3(); } } } return singleton; }} 多线程环境下，变种3更适用于性能敏感的场景。但后面我们将了解到，就算是线程安全的，还有一些办法能破坏单例。 当然，还有很多方式，能通过与volatile类似的方式防止部分初始化。读者可自行阅读内存屏障相关内容，但面试时不建议主动装逼。猴子后面会专门整理一篇文章讨论内存屏障，此处不表。 饿汉模式与饱汉相对，饿汉很饿，只想着尽早吃到。所以他就在最早的时机，即类加载时初始化单例，以后访问时直接返回即可。 12345678910// 饿汉// ThreadSafepublic class Singleton2 { private static final Singleton2 singleton = new Singleton2(); private Singleton2() { } public static Singleton2 getInstance() { return singleton; }} 饿汉的好处是天生的线程安全（得益于类加载机制），写起来超级简单，使用时没有延迟；坏处是有可能造成资源浪费（如果类加载后就一直不使用单例的话）。 值得注意的时，单线程环境下，饿汉与饱汉在性能上没什么差别；但多线程环境下，由于饱汉需要加锁，饿汉的性能反而更优。 Holder模式我们既希望利用饿汉模式中静态变量的方便和线程安全；又希望通过懒加载规避资源浪费。Holder模式满足了这两点要求：核心仍然是静态变量，足够方便和线程安全；通过静态的Holder类持有真正实例，间接实现了懒加载。 123456789101112131415// Holder模式// ThreadSafepublic class Singleton3 { private static class SingletonHolder { private static final Singleton3 singleton = new Singleton3(); private SingletonHolder() { } } private Singleton3() { } public static Singleton3 getInstance() { return SingletonHolder.singleton; }} 相对于饿汉模式，Holder模式仅增加了一个静态内部类的成本，与饱汉的变种3效果相当（略优），都是比较受欢迎的实现方式。同样建议考虑。 枚举模式用枚举实现单例模式，相当好用，但可读性是不存在的。 基础的枚举将枚举的静态成员变量作为单例的实例： 12345// 枚举// ThreadSafepublic enum Singleton4 { SINGLETON;} 代码量比饿汉模式更少。但用户只能直接访问实例Singleton4.SINGLETON——事实上，这样的访问方式作为单例使用也是恰当的，只是牺牲了静态工厂方法的优点，如无法实现懒加载。 丑陋但好用的语法糖Java的枚举是一个“丑陋但好用的语法糖”。 枚举型单例模式的本质通过反编译（jad，源码|String拼接操作”+”的优化？也用到了）打开语法糖，就看到了枚举类型的本质，简化如下： 1234567// 枚举// ThreadSafepublic class Singleton4 extends Enum&lt;Singleton4&gt; { ... public static final Singleton4 SINGLETON = new Singleton4(); ...} 本质上和饿汉模式相同，区别仅在于公有的静态成员变量。 用枚举实现一些trick这一部分与单例没什么关系，可以跳过。如果选择阅读也请认清这样的事实：虽然枚举相当灵活，但如何恰当的使用枚举有一定难度。一个足够简单的典型例子是TimeUnit类，建议有时间耐心阅读。 上面已经看到，枚举型单例的本质仍然是一个普通的类。实际上，我们可以在枚举型型单例上增加任何普通类可以完成的功能。要点在于枚举实例的初始化，可以理解为实例化了一个匿名内部类。为了更明显，我们在Singleton4_1中定义一个普通的私有成员变量，一个普通的公有成员方法，和一个公有的抽象成员方法，如下： 123456789101112131415161718192021// 枚举// ThreadSafepublic enum Singleton4_1 { SINGLETON(&quot;enum is the easiest singleton pattern, but not the most readable&quot;) { public void testAbsMethod() { print(); System.out.println(&quot;enum is ugly, but so flexible to make lots of trick&quot;); } }; private String comment = null; Singleton4_1(String comment) { this.comment = comment; } public void print() { System.out.println(&quot;comment=&quot; + comment); } abstract public void testAbsMethod(); public static Singleton4_1 getInstance() { return SINGLETON; }} 这样，枚举类Singleton4_1中的每一个枚举实例不仅继承了父类Singleton4_1的成员方法print()，还必须实现父类Singleton4_1的抽象成员方法testAbsMethod()。 总结上面的分析都忽略了反射和序列化的问题。通过反射或序列化，我们仍然能够访问到私有构造器，创建新的实例破坏单例模式。此时，只有枚举模式能天然防范这一问题。反射和序列化猴子还不太了解，但基本原理并不难，可以在其他模式上手动实现。 下面继续忽略反射和序列化的问题，做个总结回味一下： 实现方式 关键点 资源浪费 线程安全 多线程环境的性能足够优化 基础饱汉 懒加载 否 否 - 饱汉变种1 懒加载、同步 否 是 否 饱汉变种2 懒加载、DCL 否 否 - 饱汉变种3 懒加载、DCL、volatile 否 是 是 饿汉 静态变量初始化 是 是 是 Holder 静态变量初始化、holder 否 是 是 枚举 枚举本质、静态变量初始化 否 是 是","link":"/2021/09/23/java/java-singleton/"},{"title":"AbstractQueuedSynchronizer","text":"参考文章 图文并茂：AQS 是怎么运行的？ AQS 简介 Java技术之AQS详解 Java并发之AQS详解 从ReentrantLock的实现看AQS的原理及应用 1. AQS (AbstractQueuedSynchronizer) 抽象类的队列式同步器 原理概览AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。 CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。 基础定义 AQS 是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效的构造出来。 为线程的同步和等待等操作提供一个基础模板类。尽可能多的实现可重入锁，读写锁同步器所有需要的功能。队列同步器内部实现了线程的同步队列，独占或是共享的获取方式等，使其只需要少量的代码便可以实现目标功能。 一般来说，AQS的子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步。也就是说，使用ReentrantLock举例，外界调用ReentrantLock，ReentrantLock内部定义Sync，Sync是AQS的子类，在ReentrantLock的内部实现中调用Sync的方法，最后完成最终的功能，当然ReentrantLock内部稍复杂，又加入和公平锁和非公平锁。 抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...。AbstractQueuedSynchronizer，这个类也是在java.util.concurrent.locks下面。 AQS，全名AbstractQueuedSynchronizer，是一个抽象类的队列式同步器，它的内部通过维护一个状态volatile int state(共享资源)，一个FIFO线程等待队列来实现同步功能。 state 所有通过AQS实现功能的类都是通过修改state的状态来操作线程的同步状态。比如在ReentrantLock中，一个锁中只有一个state状态，当state为0时，代表所有线程没有获取锁，当state为1时，代表有线程获取到了锁。通过是否能把state从0设置成1，当然，设置的方式是使用CAS设置，代表一个线程是否获取锁成功。 state用关键字volatile修饰，代表着该共享资源的状态一更改就能被所有线程可见，而AQS的加锁方式本质上就是多个线程在竞争state，当state为0时代表线程可以竞争锁，不为0时代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个FIFO的等待队列中，这些线程会被UNSAFE.park()操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。 AQS内部维护一个线程的队列。队列由内部的节点组成。 队列的节点为Node,节点分为SHARED和EXCLUSIVE分别时共享模式的节点和独占模式的节点。 而这个等待队列其实就相当于一个CLH队列，用一张原理图来表示大致如下： AQS支持两种资源分享的方式： Exclusive（独占，只有一个线程能执行，如ReentrantLock） Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。 自定义的同步器继承AQS后，只需要实现·共享资源state的获取和释放方式·即可，其他如线程队列的维护（如获取资源失败入队/唤醒出队等）等操作，AQS在顶层已经实现了， AQS代码内部提供了一系列操作锁和线程队列的方法，主要操作锁的方法包含以下几个： compareAndSetState()：利用CAS的操作来设置state的值- tryAcquire(int)：独占方式获取锁。成功则返回true，失败则返回false。 tryRelease(int)：独占方式释放锁。成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式释放锁。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式释放锁。如果释放后允许唤醒后续等待结点返回true，否则返回false。 像ReentrantLock就是实现了自定义的tryAcquire-tryRelease，从而操作state的值来实现同步效果。 除此之外，AQS内部还定义了一个静态类Node，表示CLH队列的每一个结点，该结点的作用是对每一个等待获取资源做了封装，包含了需要同步的线程本身、线程等待状态….. 我们可以看下该类的一些重点变量： 1234567891011121314151617181920static final class Node { /** 表示共享模式下等待的Node */ static final Node SHARED = new Node(); /** 表示独占模式下等待的mode */ static final Node EXCLUSIVE = null; /** 下面几个为waitStatus的具体值 */ static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus; /** 表示前面的结点 */ volatile Node prev; /** 表示后面的结点 */ volatile Node next; /**当前结点装载的线程，初始化时被创建，使用后会置空*/ volatile Thread thread; /**链接到下一个节点的等待条件，用到Condition的时候会使用到*/ Node nextWaiter;} 代码里面定义了一个表示当前Node结点等待状态的字段waitStatus，该字段的取值包含了CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)、0，这五个值代表了不同的特定场景： CANCELLED：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。 SIGNAL：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL（记住这个-1的值，因为后面我们讲的时候经常会提到） CONDITION：表示结点等待在Condition上，当其他线程调用了Condition的SIGNAL()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。(注：Condition是AQS的一个组件，后面会细说) PROPAGATE：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。 0：新结点入队时的默认状态。 也就是说，当waitStatus为负值表示结点处于有效等待状态，为正值的时候表示结点已被取消。 在AQS内部中还维护了两个Node对象head和tail，一开始默认都为null 12private transient volatile Node head; private transient volatile Node tail; 讲完了AQS的一些基础定义，我们就可以开始学习同步的具体运行机制了，为了更好的演示，我们用ReentrantLock作为使用入口，一步步跟进源码探究AQS底层是如何运作的，这里说明一下，因为ReentrantLock底层调用的AQS是独占模式，所以下文讲解的AQS源码也是针对独占模式的操作 独占模式 ReentrantLock和synchronized功能类似，使用AQS的独占模式，只有一个线程可以获取锁。 加锁过程我们都知道，ReentrantLock的加锁和解锁方法分别为lock()和unLock()，我们先来看获取锁的方法， 123456final void lock(){ if(compareAndSetState(0,1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } 其中compareAndSetState(0, 1)如果返回true就代表着之前state是0，也就是当前无线程获取锁，同时当前线程获取锁成功了，将独占线程设置为当前线程。 如果是false就代表当前有线程占用，当前占用的线程有2个可能 当前线程在占用，因为是可重入锁，之后同样会获取锁 其他线程在占用，在其他线程占用期间，当前线程需要等待 逻辑很简单，线程进来后直接利用CAS尝试抢占锁，如果抢占成功state值回被改为1，且设置对象独占锁线程为当前线程，否则就调用acquire(1)再次尝试获取锁。 我们假定有两个线程A和B同时竞争锁，A进来先抢占到锁，此时的AQS模型图就类似这样： acquire acquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了。 acquire方法是一种互斥模式，且忽略中断。该方法至少执行一次tryAcquire(int)方法，如果tryAcquire(int)方法返回true，则acquire直接返回，否则当前线程需要进入队列进行排队。 1234public final void acquire(int arg){ if(!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE),arg)) selfInterrupt(); } acquire(1)包含整个获取锁，如果获取不到就等待的操作 acquire包含了几个函数的调用， tryAcquire：尝试直接获取锁，如果成功就直接返回； addWaiter：获取不到锁时,说明有其他线程目前正在占用锁, 将该线程加入等待队列FIFO的尾部，并标记为独占模式； acquireQueued：线程阻塞在等待队列中获取锁，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 selfInterrupt：自我中断，就是既拿不到锁，又在等待时被中断了，线程就会进行自我中断selfInterrupt()，将中断补上。 我们一个个来看源码，并结合上面的两个线程来做场景分析。 tryAcquire 在tryAcquire(arg)中是尝试获取锁,是由ReentrantLock提供的,逻辑比较简单当前无线程占有锁时,即state为0时,获取锁 当前有线程占有锁,但当前占有锁的线程是当前线程时,因为ReentrantLock是可重入锁,获取锁,并把state+1 1234567891011121314151617181920212223protected final boolean tryAcquire(int acquires){ return nonfairTryAcquire(acquires); }final boolean nonfairTryAcquire(int acquires){final Thread current=Thread.currentThread(); int c=getState(); if(c==0){ if(compareAndSetState(0,acquires)){ setExclusiveOwnerThread(current); return true; } }else if(current==getExclusiveOwnerThread()){ //当前占有锁的线程是当前线程时,因为ReentrantLock是可重入锁,获取锁,并把state+1 int nextc=c+acquires; if(nextc&lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; } 当线程B进来后，nonfairTryAcquire方法首先会获取state的值，如果为0，则正常获取该锁，不为0的话判断是否是当前线程占用了，是的话就累加state的值，这里的累加也是为了配合释放锁时候的次数，从而实现可重入锁的效果。 当然，因为之前锁已经被线程A占领了，所以这时候tryAcquire会返回false，继续下面的流程。 addWaiter获取不到锁时,说明有其他线程目前正在占用锁,将当前线程包装成节点放入同步队列 将该线程加入等待队列FIFO的尾部，并标记为独占模式； 123456789101112131415161718/** 先尝试快速入队，如果入队成功直接返回，如果失败（存在竞态）就使用cas反复入队直到成功为止 **/private Node addWaiter(Node mode){ Node node=new Node(Thread.currentThread(),mode); // Try the fast path of enq; backup to full enq on failure // //快速入队 Node pred=tail; if(pred!=null){ node.prev=pred; if(compareAndSetTail(pred,node)){ pred.next=node; return node; } } enq(node); return node; } 这段代码首先会创建一个和当前线程绑定的Node节点，Node为双向链表。此时等待队列中的tail指针为空，直接调用enq(node)方法将当前线程加入等待队列尾部，然后返回当前结点的前驱结点， enq用于将当前节点插入等待队列，如果队列为空，则初始化当前队列。整个过程以CAS自旋的方式进行，直到成功加入队尾为止。 1234567891011121314151617private Node enq(final Node node){ // CAS&quot;自旋&quot;，直到成功加入队尾 for(;;){ Node t=tail; if(t==null){ // 队列为空，初始化一个Node结点作为Head结点，并将tail结点也指向它 if(compareAndSetHead(new Node())) tail=head; }else{ // 把当前结点插入队列尾部 node.prev=t; if(compareAndSetTail(t,node)){ t.next=node; return t; } } } } 第一遍循环时，tail指针为空，初始化一个Node结点，并把head和tail结点都指向它，然后第二次循环进来之后，tail结点不为空了，就将当前的结点加入到tail结点后面，也就是这样： 如果此时有另一个线程C进来的话，发现锁已经被A拿走了，然后队列里已经有了线程B，那么线程C就只能乖乖排到线程B的后面去， 入队完成之后再判断一次当前是否有可能获得锁，也就是前一个节点是head的话， 前一个线程有可能已经释放了，再获取一次，如果获取成功，设置当前节点为头节点，整个获取过程完成。 acquireQueued接着解读方法，通过tryAcquire()和addWaiter()，我们的线程还是没有拿到资源，并且还被排到了队列的尾部，如果让你来设计的话，这个时候你会怎么处理线程呢？其实答案也很简单，能做的事无非两个： 1、循环让线程再抢资源。但仔细一推敲就知道不合理，因为如果有多个线程都参与的话，你抢我也抢只会降低系统性能 2、进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源 毫无疑问，选择2更加靠谱，acquireQueued方法做的也是这样的处理： acquireQueued()用于队列中的线程自旋地以独占且不可中断的方式获取同步状态（acquire），直到拿到锁之后再返回。该方法的实现分成两部分：如果当前节点已经成为头结点，尝试获取锁（tryAcquire）成功，然后返回；否则检查当前节点是否应该被park，然后将该线程park并且检查当前线程是否被可以被中断。 12345678910111213141516171819202122 final boolean acquireQueued(final Node node,int arg){ boolean failed=true; try{ // 标记是否会被中断 boolean interrupted=false; // CAS自旋 for(;;){// 获取当前结点的前结点 final Node p=node.predecessor(); if(p==head&amp;&amp;tryAcquire(arg)){ setHead(node); p.next=null; // help GC failed=false; return interrupted; } if(shouldParkAfterFailedAcquire(p,node)&amp;&amp;parkAndCheckInterrupt()) interrupted=true; } }finally{ if(failed) // 获取锁失败，则将此线程对应的node的waitStatus改为CANCEL cancelAcquire(node); } } shouldParkAfterFailedAcquire(Node, Node)shouldParkAfterFailedAcquire方法通过对当前节点的前一个节点的状态进行判断，对当前节点做出不同的操作，至于每个Node的状态表示，可以参考接口文档。 12345678910111213141516171819 private static boolean shouldParkAfterFailedAcquire(Node pred,Node node){ int ws=pred.waitStatus; if(ws==Node.SIGNAL) // 前驱结点等待状态为&quot;SIGNAL&quot;，那么自己就可以安心等待被唤醒了 return true; if(ws&gt;0){ /* * 前驱结点被取消了，通过循环一直往前找，直到找到等待状态有效的结点(等待状态值小于等于0) ， * 然后排在他们的后边，至于那些被当前Node强制&quot;靠后&quot;的结点，因为已经被取消了，也没有引用链， * 就等着被GC了 */ do{ node.prev=pred=pred.prev; }while(pred.waitStatus&gt;0); pred.next=node; }else{ // 如果前驱正常，那就把前驱的状态设置成SIGNAL compareAndSetWaitStatus(pred,ws,Node.SIGNAL); } return false; }private final boolean parkAndCheckInterrupt(){ LockSupport.park(this); return Thread.interrupted(); } acquireQueued方法的流程是这样的： 1、CAS自旋，先判断当前传入的Node的前结点是否为head结点，是的话就尝试获取锁，获取锁成功的话就把当前结点置为head，之前的head置为null(方便GC)，然后返回 2、如果前驱结点不是head或者加锁失败的话，就调用 shouldParkAfterFailedAcquire，将前驱节点的waitStatus变为了SIGNAL=-1，最后执行 parkAndChecknIterrupt 方法，调用 LockSupport.park()挂起当前线程，parkAndCheckInterrupt在挂起线程后会判断线程是否被中断，如果被中断的话，就会重新跑acquireQueued方法的CAS自旋操作，直到获取资源。 ps：LockSupport.park方法会让当前线程进入waitting状态，在这种状态下，线程被唤醒的情况有两种，一是被unpark()，二是被interrupt()，所以，如果是第二种情况的话，需要返回被中断的标志，然后在acquire顶层方法的窗口那里自我中断补上 此时，因为线程A还未释放锁，所以线程B状态都是被挂起的， 到这里，加锁的流程就分析完了. 获取锁并等待的过程:当lock()执行的时候： 先快速获取锁，当前没有线程执行的时候直接获取锁 尝试获取锁，当没有线程执行或是当前线程占用锁，可以直接获取锁 将当前线程包装为node放入同步队列，设置为尾节点 前一个节点如果为头节点，再次尝试获取一次锁 将前一个有效节点设置为SIGNAL 然后阻塞直到被唤醒 为了方便你们更加清晰理解，我加多一张流程图 释放锁说完了加锁，我们来看看释放锁是怎么做的，AQS中释放锁的方法是release()，当调用该方法时会释放指定量的资源 (也就是锁) ，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。 release当ReentrantLock进行释放锁操作时，调用的是AQS的release(1)操作 123456789public final boolean release(int arg){ if(tryRelease(arg)){ Node h=head; if(h!=null&amp;&amp;h.waitStatus!=0) unparkSuccessor(h); return true; } return false; } tryRelease代码上可以看出，核心的逻辑都在tryRelease方法中，该方法的作用是释放资源，AQS里该方法没有具体的实现，需要由自定义的同步器去实现，我们看下ReentrantLock代码中对应方法的源码： 在tryRelease(arg)中会将锁释放一次，如果当前state是1，且当前线程是正在占用的线程，释放锁成功，返回true，否则因为是可重入锁，释放一次可能还在占用，应一直释放直到state为0为止 123456789101112protected final boolean tryRelease(int releases){ int c=getState()-releases; if(Thread.currentThread()!=getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free=false; if(c==0){ free=true; setExclusiveOwnerThread(null); } setState(c); return free; } tryRelease方法会减去state对应的值，如果state为0，也就是已经彻底释放资源，就返回true，并且把独占的线程置为null，否则返回false。 此时AQS中的数据就会变成这样： unparkSuccessor完全释放资源后，当前线程要做的就是唤醒CLH队列中第一个在等待资源的线程，也就是head结点后面的线程，此时调用的方法是unparkSuccessor()， 然后优先找下一个节点，如果取消了就从尾节点开始找，找到最前面一个可用的节点 将其取消阻塞状态。 123456789101112131415161718 private void unparkSuccessor(Node node){int ws=node.waitStatus;if(ws&lt; 0) //将head结点的状态置为0 compareAndSetWaitStatus(node,ws,0);//找到下一个需要唤醒的结点s Node s=node.next;//如果为空或已取消 if(s==null||s.waitStatus&gt;0){s=null;// 从后向前，直到找到等待状态小于0的结点，前面说了，结点waitStatus小于0时才有效 for(Node t=tail;t!=null&amp;&amp;t!=node;t=t.prev)if(t.waitStatus&lt;=0)s=t;}// 找到有效的结点，直接唤醒 if(s!=null)LockSupport.unpark(s.thread);//唤醒} 方法的逻辑很简单，就是先将head的结点状态置为0，避免下面找结点的时候再找到head，然后找到队列中最前面的有效结点，然后唤醒，我们假设这个时候线程A已经释放锁，那么此时队列中排最前边竞争锁的线程B就会被唤醒。然后被唤醒的线程B就会尝试用CAS获取锁，回到acquireQueued方法的逻辑， 阻塞在acquireQueued的地方在唤醒之后开始继续执行，当前节点已经是最前面的一个可用（未取消）节点了,经过不断的for循环以及在shouldParkAfterFailedAcquire中不断向前寻找可用节点，因此这个被唤醒的节点一定可以使其之前的节点为head。然后获取锁成功。 但是此时节点会与新加入的节点竞争，也就是不公平锁的由来。 在公平锁中，在tryAcquire时会判断之前是否有等待的节点hasQueuedPredecessors(),如果有就不会再去获取锁了,因此能保证顺序执行。 12345678910111213for(;;){// 获取当前结点的前结点 final Node p=node.predecessor(); if(p==head&amp;&amp;tryAcquire(arg)){ setHead(node); p.next=null; // help GC failed=false; return interrupted; } if(shouldParkAfterFailedAcquire(p,node)&amp;&amp;parkAndCheckInterrupt()) interrupted=true; } 当线程B获取锁之后，会把当前结点赋值给head，然后原先的前驱结点 (也就是原来的head结点) 去掉引用链，方便回收，这样一来，线程B获取锁的整个过程就完成了，此时AQS的数据就会变成这样：到这里，我们已经分析完了AQS独占模式下加锁和释放锁的过程，也就是tryAccquire-&gt;tryRelease这一链条的逻辑，除此之外，AQS中还支持共享模式的同步，这种模式下关于锁的操作核心其实就是tryAcquireShared-&gt;tryReleaseShared这两个方法，我们可以简单看下 共享模式 ReentrantReadWriteLock是Java中读写锁的实现，写写互斥，读写互斥，读读共享。读写锁在内部分为读锁和写锁，因为我们要探索共享模式，因此更关注读锁。 获取锁AQS中，共享模式获取锁的顶层入口方法是acquireShared，该方法会获取指定数量的资源，成功的话就直接返回，失败的话就进入等待队列，直到获取资源， 1234public final void acquireShared(int arg){ if(tryAcquireShared(arg)&lt; 0) doAcquireShared(arg); } 该方法里包含了两个方法的调用， tryAcquireShared：尝试获取一定资源的锁，返回的值代表获取锁的状态。 doAcquireShared：进入等待队列，并循环尝试获取锁，直到成功。 tryAcquireSharedtryAcquireShared在AQS里没有实现，同样由自定义的同步器去完成具体的逻辑，像一些较为常见的并发工具Semaphore、CountDownLatch里就有对该方法的自定义实现，虽然实现的逻辑不同，但方法的作用是一样的，就是获取一定资源的资源，然后根据返回值判断是否还有剩余资源，从而决定下一步的操作。 返回值有三种定义： 负值代表获取失败； (当前有写锁，返回-1，即未获取共享锁，需要执行下一步doAcquireShared) 0代表获取成功，但没有剩余的资源，也就是state已经为0； 正值代表获取成功，而且state还有剩余，其他线程可以继续领取 当返回值小于0时，证明此次获取一定数量的锁失败了，然后就会走doAcquireShared方法 123456789101112131415protected final int tryAcquireShared(int unused){ Thread current=Thread.currentThread(); int c=getState(); if(exclusiveCount(c)!=0&amp;&amp; getExclusiveOwnerThread()!=current) return-1; int r=sharedCount(c); if(!readerShouldBlock()&amp;&amp; r&lt;MAX_COUNT &amp;&amp; compareAndSetState(c,c+SHARED_UNIT)){ //设置firstReader，计算数量，略 return 1; } return fullTryAcquireShared(current); } 设置共享锁需要修改state的数量，表示获取共享锁的线程的数量，当共享锁的获取存在竞争时，即compareAndSetState(c, c + SHARED_UNIT))可能设置失败，此时进入fullTryAcquireShared(current)进行获取共享锁的完整版操作。 也就是说共享锁获取时：如果当前没有独占锁在占用，AQS根据其实现类的tryAcquireShared来实现让一个共享锁直接获取到锁(可以直接执行)当有独占锁在占用是，让共享锁去等待直到独占锁解锁为止，也就是doAcquireShared(arg)的逻辑 doAcquireShared此方法的作用是将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回，这是它的源码： 12345678910111213141516171819202122232425262728293031323334 private void doAcquireShared(int arg){// 加入队列尾部final Node node=addWaiter(Node.SHARED); boolean failed=true; try{ boolean interrupted=false; // CAS自旋 for(;;){final Node p=node.predecessor(); // 判断前驱结点是否是head if(p==head){ // 尝试获取一定数量的锁 int r=tryAcquireShared(arg); if(r&gt;=0){ // 获取锁成功，而且还有剩余资源，就设置当前结点为head，并继续唤醒下一个线程 setHeadAndPropagate(node,r); // 让前驱结点去掉引用链，方便被GC p.next=null; // help GC if(interrupted) selfInterrupt(); failed=false; return; } } // 跟独占模式一样，改前驱结点waitStatus为-1，并且当前线程挂起，等待被唤醒 if(shouldParkAfterFailedAcquire(p,node)&amp;&amp;parkAndCheckInterrupt()) interrupted=true; } }finally{ if(failed) cancelAcquire(node); } } doAcquireShared(arg) 除了将线程封装成节点入队外还表达了3个思想： 什么时候该执行 什么时候该传播 什么时候该等待（阻塞） 其中入队、执行和等待的逻辑基本和独占锁一样， 入队：都是加入等待队列的末尾，成为tail节点； 执行：判断当前节点的前一个节点是不是头节点，如果是的话尝试获取锁，如果获取到了就执行； 等待：获取不到或前一个节点不是头节点就代表该线程需要暂时等待，直到被叫醒为止。设置前一个节点为SIGNAL状态，然后进入等待。 其中不同的就是共享锁的传播逻辑： 想象一下，当前有一个写锁正在占用，有多个读锁在等待，当写锁释放时，第二个线程也就是想要获取读锁的线程就可以获取锁了。获取到之后当前正在用的锁就是读锁了，那后面的读锁呢，因为读锁是共享的，后面的读锁应该也能够依次获取读锁，也就是读锁的传播机制。 1234567891011 private void setHeadAndPropagate(Node node,int propagate){Node h=head;// head指向自己 setHead(node);// 如果还有剩余量，继续唤醒下一个邻居线程 if(propagate&gt;0||h==null||h.waitStatus&lt; 0){Node s=node.next;if(s==null||s.isShared())doReleaseShared();}} 将当前的节点设置为头节点，判断如果是共享锁，执行doReleaseShared()，唤醒当前节点 123456789101112131415161718private void doReleaseShared(){for(;;){Node h=head;if(h!=null&amp;&amp;h!=tail){int ws=h.waitStatus;if(ws==Node.SIGNAL){if(!compareAndSetWaitStatus(h,Node.SIGNAL,0))continue;unparkSuccessor(h);}else if(ws==0&amp;&amp;!compareAndSetWaitStatus(h,0,Node.PROPAGATE))continue;}if(h==head)break;}} 当前节点唤醒之后doAcquireShared(int arg)会继续执行,因为之前的节点被设置为头节点,如果后续是获取共享锁的节点会继续执行setHeadAndPropagate,一直传播下去直到遇到获取独占锁的节点。 看到这里，你会不会一点熟悉的感觉，这个方法的逻辑怎么跟上面那个acquireQueued() 那么类似啊？对的，其实两个流程并没有太大的差别。只是doAcquireShared()比起独占模式下的获取锁上多了一步唤醒后继线程的操作，当获取完一定的资源后，发现还有剩余的资源，就继续唤醒下一个邻居线程，这才符合”共享”的思想嘛。 这里我们可以提出一个疑问，共享模式下，当前线程释放了一定数量的资源，但这部分资源满足不了下一个等待结点的需要的话，那么会怎么样？ 按照正常的思维，共享模式是可以多个线程同时执行的才对，所以，多个线程的情况下，如果老大释放完资源，但这部分资源满足不了老二，但能满足老三，那么老三就可以拿到资源。可事实是，从源码设计中可以看出，如果真的发生了这种情况，老三是拿不到资源的，因为等待队列是按顺序排列的，老二的资源需求量大，会把后面量小的老三以及老四、老五等都给卡住。从这一个角度来看，虽然AQS严格保证了顺序，但也降低了并发能力 接着往下说吧，唤醒下一个邻居线程的逻辑在doReleaseShared()中，我们放到下面的释放锁来解析。 共享锁的获取总结如下： 尝试获取共享锁，如果当前是共享锁或无锁，设置共享锁的state,获取锁 如果当前是写锁，进入等待流程 入队，加入等待队列的末尾，成为tail节点 判断当前节点的前一个节点是不是头节点，如果是的话尝试获取锁，如果获取到了就执行 获取不到或前一个节点不是头节点就代表该线程需要暂时等待，直到被叫醒为止。设置前一个节点为SIGNAL状态，然后进入等待 如果可以获取到锁，设置头节点并进入共享锁节点传播流程 释放锁共享模式释放锁的顶层方法是releaseShared，它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码： 1234567public final boolean releaseShared(int arg){ if(tryReleaseShared(arg)){ doReleaseShared(); return true; } return false; } 该方法同样包含两部分的逻辑： tryReleaseShared：释放资源。 doAcquireShared：唤醒后继结点。 跟tryAcquireShared方法一样，tryReleaseShared在AQS中没有具体的实现，由子同步器自己去定义，但功能都一样，就是释放一定数量的资源。 释放完资源后，线程不会马上就收工，而是唤醒等待队列里最前排的等待结点。 tryReleaseShared在tryReleaseShared(arg)，基本就是tryAcquireShared(int unused)的反向操作 将设置的HoldCounter减少，firstReader设置null，state减少,将tryAcquireShared(int unused)添加的状态全部反向还原回去 当共享锁全部释放完毕，返回true，否则返回false doAcquireShared唤醒后继结点的工作在doReleaseShared()方法中完成，我们可以看下它的源码： 123456789101112131415161718192021 private void doReleaseShared(){for(;;){// 获取等待队列中的head结点 Node h=head;if(h!=null&amp;&amp;h!=tail){int ws=h.waitStatus;// head结点waitStatus = -1,唤醒下一个结点对应的线程 if(ws==Node.SIGNAL){if(!compareAndSetWaitStatus(h,Node.SIGNAL,0))continue;// loop to recheck cases// 唤醒后继结点 unparkSuccessor(h);}else if(ws==0&amp;&amp;!compareAndSetWaitStatus(h,0,Node.PROPAGATE))continue;// loop on failed CAS }if(h==head)// loop if head changed break; }} 代码没什么特别的，就是如果等待队列head结点的waitStatus为-1的话，就直接唤醒后继结点，唤醒的方法unparkSuccessor()在上面已经讲过了，这里也没必要再复述。 总的来看，AQS共享模式的运作流程和独占模式很相似。 2. Condition介绍完了AQS的核心功能，我们再扩展一个知识点，在AQS中，除了提供独占/共享模式的加锁/解锁功能，它还对外提供了关于Condition的一些操作方法。 Condition是个接口，在jdk1.5版本后设计的，基本的方法就是await()和SIGNAL()方法，功能大概就对应Object的wait()和notify()，Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现，AQS中就定义了一个类ConditionObject来实现了这个接口，那么它应该怎么用呢？我们可以简单写个demo来看下效果 123456789101112131415161718192021222324252627282930313233public class ConditionDemo { public static void main(String[] args) { ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); Thread tA = new Thread(() -&gt; { lock.lock(); try { System.out.println(&quot;线程A加锁成功&quot;); System.out.println(&quot;线程A执行await被挂起&quot;); condition.await(); System.out.println(&quot;线程A被唤醒成功&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); System.out.println(&quot;线程A释放锁成功&quot;); } }); Thread tB = new Thread(() -&gt; { lock.lock(); try { System.out.println(&quot;线程B加锁成功&quot;); condition.SIGNAL(); System.out.println(&quot;线程B唤醒线程A&quot;); } finally { lock.unlock(); System.out.println(&quot;线程B释放锁成功&quot;); } }); tA.start(); tB.start(); }} 执行main函数后结果输出为： 1234567线程A加锁成功 线程A执行await被挂起 线程B加锁成功 线程B唤醒线程A 线程B释放锁成功 线程A被唤醒成功 线程A释放锁成功 代码执行的结果很容易理解，线程A先获取锁，然后调用await()方法挂起当前线程并释放锁，线程B这时候拿到锁，然后调用SIGNAL唤醒线程A。 毫无疑问，这两个方法让线程的状态发生了变化，我们仔细来研究一下， 翻看AQS的源码，我们会发现Condition中定义了两个属性firstWaiter和lastWaiter，前面说了，AQS中包含了一个FIFO的CLH等待队列，每个Conditon对象就包含这样一个等待队列，而这两个属性分别表示的是等待队列中的首尾结点， 1234/** First node of condition queue. */private transient Node firstWaiter;/** Last node of condition queue. */private transient Node lastWaiter; 注意：Condition当中的等待队列和AQS主体的同步等待队列是分开的，两个队列虽然结构体相同，但是作用域是分开的 await先看await()的源码： 12345678910111213141516171819202122 public final void await()throws InterruptedException{if(Thread.interrupted())throw new InterruptedException();// 将当前线程加入到等待队列中 Node node=addConditionWaiter();// 完全释放占有的资源，并返回资源数 int savedState=fullyRelease(node);int interruptMode=0;// 循环判断当前结点是不是在Condition的队列中，是的话挂起 while(!isOnSyncQueue(node)){LockSupport.park(this);if((interruptMode=checkInterruptWhileWaiting(node))!=0)break;}if(acquireQueued(node,savedState)&amp;&amp;interruptMode!=THROW_IE)interruptMode=REINTERRUPT;if(node.nextWaiter!=null)// clean up if cancelled unlinkCancelledWaiters();if(interruptMode!=0)reportInterruptAfterWait(interruptMode);} 当一个线程调用 Condition.await()方法，将会以当前线程构造结点，这个结点的waitStatus赋值为Node.CONDITION， 也就是-2，并将结点从尾部加入等待队列，然后尾部结点就会指向这个新增的结点， 123456789101112131415 private Node addConditionWaiter(){Node t=lastWaiter;// If lastWaiter is cancelled, clean out. if(t!=null&amp;&amp;t.waitStatus!=Node.CONDITION){unlinkCancelledWaiters();t=lastWaiter;}Node node=new Node(Thread.currentThread(),Node.CONDITION);if(t==null)firstWaiter=node;elset.nextWaiter=node;lastWaiter=node;return node;} 我们依然用上面的demo来演示，此时，线程A获取锁并调用Condition.await()方法后，AQS内部的数据结构会变成这样：在Condition队列中插入对应的结点后，线程A会释放所持有的资源，走到while循环那层逻辑， 12345while(!isOnSyncQueue(node)){ LockSupport.park(this); if((interruptMode=checkInterruptWhileWaiting(node))!=0) break; } isOnSyncQueue方法的会判断当前的线程节点是不是在同步队列中，这个时候此结点还在Condition队列中，所以该方法返回false，这样的话循环会一直持续下去，线程被挂起，等待被唤醒，此时，线程A的流程暂时停止了。 当线程A调用await()方法挂起的时候，线程B获取到了线程A释放的资源，然后执行SIGNAL()方法： SIGNAL1234567public final void SIGNAL(){ if(!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first=firstWaiter; if(first!=null) doSIGNAL(first); } 先判断当前线程是否为获取锁的线程，如果不是则直接抛出异常。接着调用doSIGNAL()方法来唤醒线程。 12345678910111213141516171819 private void doSIGNAL(Node first){ // 循环，从队列一直往后找不为空的首结点 do{ if((firstWaiter=first.nextWaiter)==null) lastWaiter=null; first.nextWaiter=null; }while(!transferForSIGNAL(first)&amp;&amp;(first=firstWaiter)!=null); }final boolean transferForSIGNAL(Node node){ // CAS循环，将结点的waitStatus改为0 if(!compareAndSetWaitStatus(node,Node.CONDITION,0)) return false; // 上面已经分析过，此方法会把当前结点加入到等待队列中，并返回前驱结点 Node p=enq(node); int ws=p.waitStatus; if(ws&gt;0||!compareAndSetWaitStatus(p,ws,Node.SIGNAL)) LockSupport.unpark(node.thread); return true; } 从doSIGNAL的代码中可以看出，这时候程序寻找的是Condition等待队列中首结点firstWaiter的结点，此时该结点指向的是线程A的结点，所以之后的流程作用的都是线程A的结点。 这里分析下transferForSIGNAL方法，先通过CAS自旋将结点waitStatus改为0，然后就把结点放入到同步队列 (此队列不是Condition的等待队列) 中，然后再用CAS将同步队列中该结点的前驱结点waitStatus改为Node.SIGNAL，也就是-1，此时AQS的数据结构大概如下(额…..少画了个箭头，大家就当head结点是线程A结点的前驱结点就好)：回到await()方法，当线程A的结点被加入同步队列中时，isOnSyncQueue()会返回true，跳出循环， 123456789101112 while(!isOnSyncQueue(node)){LockSupport.park(this);if((interruptMode=checkInterruptWhileWaiting(node))!=0)break;}if(acquireQueued(node,savedState)&amp;&amp;interruptMode!=THROW_IE)interruptMode=REINTERRUPT;if(node.nextWaiter!=null)// clean up if cancelled unlinkCancelledWaiters();if(interruptMode!=0)reportInterruptAfterWait(interruptMode); 接着执行acquireQueued()方法，这里就不用多说了吧，尝试重新获取锁，如果获取锁失败继续会被挂起，直到另外线程释放锁才被唤醒。 所以，当线程B释放完锁后，线程A被唤醒，继续尝试获取锁，至此流程结束。 对于这整个通信过程，我们可以画一张流程图展示下： 总结说完了Condition的使用和底层运行机制，我们再来总结下它跟普通 wait/notify 的比较，一般这也是问的比较多的，Condition大概有以下两点优势： Condition 需要结合 Lock 进行控制，使用的时候要注意一定要对应的unlock()，可以对多个不同条件进行控制，只要new 多个 Condition对象就可以为多个线程控制通信，wait/notify 只能和 synchronized 关键字一起使用，并且只能唤醒一个或者全部的等待队列； Condition 有类似于 await 的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是 park/unpark 的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁，但是 wait/notify 会产生先唤醒再挂起的死锁。 无论是独占还是共享模式，或者结合是Condition工具使用，AQS本质上的同步功能都是通过对锁和队列中结点的操作来实现的， 3. ReentrantLockReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下：下面通过伪代码，进行更加直观的比较： 1234567891011121314151617181920212223242526272829// **************************Synchronized的使用方式**************************// 1.用于代码块synchronized (this){}// 2.用于对象synchronized (object){}// 3.用于方法public synchronized void test(){} // 4.可重入 for(int i=0;i&lt; 100;i++){synchronized (this){} }// **************************ReentrantLock的使用方式**************************public void test()throw Exception{ // 1.初始化选择公平锁、非公平锁 ReentrantLock lock=new ReentrantLock(true); // 2.可用于代码块 lock.lock(); try{ try{ // 3.支持多种加锁方式，比较灵活; 具有可重入特性 if(lock.tryLock(100,TimeUnit.MILLISECONDS)){} }finally{ // 4.手动释放锁 lock.unlock() } }finally{ lock.unlock(); } } ReentrantLock 最基本的使用方式123456789101112class X { private final ReentrantLock lock = new ReentrantLock(); public void m() { lock.lock(); try { doSomething(); } finally { lock.unlock() } }} 当创建ReentrantLock时默认使用非公平锁，效率高于公平锁，暂不讨论公平锁。 ReentrantReadWriteLock的读锁的最基本的使用方式如下123456789101112class X { private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public void m() { rwl.readLock().lock(); try { read(); } finally { rwl.readLock().unlock(); } }} 2. synchronizesynchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。Synchronized主要有以下三个作用：保证互斥性、保证可见性、保证顺序性。 synchronize与lock的区别","link":"/2021/09/23/java/java_aqs/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"jdk","slug":"jdk","link":"/tags/jdk/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"java锁","slug":"java锁","link":"/tags/java%E9%94%81/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"jdk","slug":"jdk","link":"/categories/jdk/"},{"name":"centos","slug":"centos","link":"/categories/centos/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"wsl","slug":"wsl","link":"/categories/wsl/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"},{"name":"java","slug":"java","link":"/categories/java/"}]}