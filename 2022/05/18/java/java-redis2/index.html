<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>java redis2 - Summer</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Summer"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Summer"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Redis 的数据类型有哪些字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。"><meta property="og:type" content="blog"><meta property="og:title" content="java redis2"><meta property="og:url" content="https://luochunhai.github.io/2022/05/18/java/java-redis2/"><meta property="og:site_name" content="Summer"><meta property="og:description" content="Redis 的数据类型有哪些字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://luochunhai.github.io/img/og_image.png"><meta property="article:published_time" content="2022-05-18T06:25:41.000Z"><meta property="article:modified_time" content="2022-05-25T05:12:13.967Z"><meta property="article:author" content="Luo Chunhai"><meta property="article:tag" content="java"><meta property="article:tag" content="redis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://luochunhai.github.io/2022/05/18/java/java-redis2/"},"headline":"java redis2","image":["https://luochunhai.github.io/img/og_image.png"],"datePublished":"2022-05-18T06:25:41.000Z","dateModified":"2022-05-25T05:12:13.967Z","author":{"@type":"Person","name":"Luo Chunhai"},"publisher":{"@type":"Organization","name":"Summer","logo":{"@type":"ImageObject","url":{"text":"Summer"}}},"description":"Redis 的数据类型有哪些字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。"}</script><link rel="canonical" href="https://luochunhai.github.io/2022/05/18/java/java-redis2/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Summer</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/luochunhai"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Summer" href="http://www.luochunhai.club/"><i class="fas fa-link"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-18T06:25:41.000Z" title="5/18/2022, 2:25:41 PM">2022-05-18</time>发表</span><span class="level-item"><time dateTime="2022-05-25T05:12:13.967Z" title="5/25/2022, 1:12:13 PM">2022-05-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">1 小时读完 (大约9491个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">java redis2</h1><div class="content"><h2 id="Redis-的数据类型有哪些"><a href="#Redis-的数据类型有哪些" class="headerlink" title="Redis 的数据类型有哪些"></a>Redis 的数据类型有哪些</h2><p>字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，<br>除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。</p>
<span id="more"></span>


<h2 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h2><p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。</p>
<p>实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p>
<p>RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br>AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p>
<p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<h2 id="缓存雪崩、缓存穿透、击穿、缓存预热、缓存更新、缓存降级等问题"><a href="#缓存雪崩、缓存穿透、击穿、缓存预热、缓存更新、缓存降级等问题" class="headerlink" title="缓存雪崩、缓存穿透、击穿、缓存预热、缓存更新、缓存降级等问题"></a>缓存雪崩、缓存穿透、击穿、缓存预热、缓存更新、缓存降级等问题</h2><p>缓存雪崩<br>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br>解决办法：<br>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。<br>缓存穿透<br>缓存穿透是指用户查询数据，<strong>在数据库没有，自然在缓存中也不会有</strong>。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>解决办法：<br>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？<br>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>Bitmap：典型的就是哈希表<br>缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。<br>布隆过滤器（推荐）<br>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。<br>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<p>缓存穿透与<strong>缓存击穿</strong>的区别<br>缓存击穿：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。<br>解决方案：在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p>
<p>给一个我公司处理的案例：背景双机拿token，token在存一份到redis，保证系统在token过期时都只有一个线程去获取token;线上环境有两台机器，故使用分布式锁实现。<br>缓存预热<br>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>解决思路：<br>·直接写个缓存刷新页面，上线时手工操作下；<br>·数据量不大，可以在项目启动的时候自动进行加载；<br>·定时刷新缓存；</p>
<p>缓存更新<br>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>·定时去清理过期的缓存；<br>·当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。<br>缓存降级<br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>以参考日志级别设置预案：<br>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。<br>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h2 id="热点数据和冷数据是什么"><a href="#热点数据和冷数据是什么" class="headerlink" title="热点数据和冷数据是什么"></a>热点数据和冷数据是什么</h2><p>热点数据，缓存才有价值<br>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存</p>
<p>对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。</p>
<p>对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。<br>数据更新前至少读取两次， 缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</p>
<p>那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h2 id="Memcache与Redis的区别都有哪些？"><a href="#Memcache与Redis的区别都有哪些？" class="headerlink" title="Memcache与Redis的区别都有哪些？"></a>Memcache与Redis的区别都有哪些？</h2><p>1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，redis可以持久化其数据<br>2)、数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储<br>3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>4). value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br>5）redis的速度比memcached快很多<br>6）Redis支持数据的备份，即master-slave模式的数据备份。</p>
<h2 id="Redis-相比-Memcached-有哪些优势？"><a href="#Redis-相比-Memcached-有哪些优势？" class="headerlink" title="Redis 相比 Memcached 有哪些优势？"></a>Redis 相比 Memcached 有哪些优势？</h2><p>Redis 相比 Memcache 有以下的优势：</p>
<p>数据结构：Memcache 只支持 key value 存储方式，Redis 支持更多的数据类型，比如 Key value、hash、list、set、zset；<br>多线程：Memcache 支持多线程，Redis 支持单线程；CPU 利用方面 Memcache 优于 Redis；<br>持久化：Memcache 不支持持久化，Redis 支持持久化；<br>内存利用率：Memcache 高，Redis 低（采用压缩的情况下比 Memcache 高）；<br>过期策略：Memcache 过期后，不删除缓存，会导致下次取数据数据的问题，Redis 有专门线程，清除缓存数据；<br>适用场景：Redis 适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统。Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。Memcached 适用于在动态系统中减少数据库负载，提升性能，做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）。</p>
<h2 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h2><p>(一)纯内存操作<br>(二)单线程操作，避免了频繁的上下文切换<br>(三)采用了非阻塞I&#x2F;O多路复用机制</p>
<h2 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h2><p>redis采用的是定期删除+惰性删除策略。<br>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.<br>定期删除+惰性删除是如何工作的呢?<br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p>采用定期删除+惰性删除就没其他问题了么?<br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置<br>maxmemory-policy volatile-lru1</p>
<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错<br>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<h2 id="Redis-为什么是单线程的"><a href="#Redis-为什么是单线程的" class="headerlink" title="Redis 为什么是单线程的"></a>Redis 为什么是单线程的</h2><p>Redis 是单进程单线程的，它可以通过队列技术将并发访问变为串行访问，避免了传统数据库串行控制的开销。<br>多线程处理会涉及到锁，并且多线程处理会涉及到线程切换而消耗 CPU。采用单线程，避免了不必要的上下文切换和竞争条件。其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p>
<p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。<br>既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问</p>
<p>1）绝大部分请求是纯粹的内存操作（非常快速）<br>2）采用单线程,避免了不必要的上下文切换和竞争条件<br>3）非阻塞IO优点：</p>
<p>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)<br>支持丰富数据类型，支持string，list，set，sorted set，hash<br>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行<br>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题</p>
<h2 id="同时有多个子系统去set一个key。这个时候要注意什么呢？"><a href="#同时有多个子系统去set一个key。这个时候要注意什么呢？" class="headerlink" title="同时有多个子系统去set一个key。这个时候要注意什么呢？"></a>同时有多个子系统去set一个key。这个时候要注意什么呢？</h2><p>不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。<br>·如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可<br>·如果对这个key操作，要求顺序：分布式锁+时间戳。假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>·利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性</p>
<p>对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。</p>
<h2 id="有没有尝试进行多机redis-的部署？如何保证数据一致的？"><a href="#有没有尝试进行多机redis-的部署？如何保证数据一致的？" class="headerlink" title="有没有尝试进行多机redis 的部署？如何保证数据一致的？"></a>有没有尝试进行多机redis 的部署？如何保证数据一致的？</h2><p>主从复制，读写分离<br>一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p>
<h2 id="对于大量的请求怎么样处理"><a href="#对于大量的请求怎么样处理" class="headerlink" title="对于大量的请求怎么样处理"></a>对于大量的请求怎么样处理</h2><p>redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；<br>redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的</p>
<h2 id="Redis-常见性能问题和解决方案？"><a href="#Redis-常见性能问题和解决方案？" class="headerlink" title="Redis 常见性能问题和解决方案？"></a>Redis 常见性能问题和解决方案？</h2><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件<br>(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3…</p>
<h2 id="讲解下Redis线程模型"><a href="#讲解下Redis线程模型" class="headerlink" title="讲解下Redis线程模型"></a>讲解下Redis线程模型</h2><p>文件事件处理器包括分别是套接字、 I&#x2F;O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I&#x2F;O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。<br>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>I&#x2F;O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>工作原理：<br>I&#x2F;O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>尽管多个文件事件可能会并发地出现， 但 I&#x2F;O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：<br>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I&#x2F;O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.</p>
<h2 id="为什么Redis的操作是原子性的，怎么保证原子性的？"><a href="#为什么Redis的操作是原子性的，怎么保证原子性的？" class="headerlink" title="为什么Redis的操作是原子性的，怎么保证原子性的？"></a>为什么Redis的操作是原子性的，怎么保证原子性的？</h2><p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>Redis的操作之所以是原子性的，是因为Redis是单线程的。（Redis新版本已经引入多线程，这里基于旧版本的Redis）<br>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。<br>多个命令在并发中也是原子性的吗？<br>不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua&#x3D;&#x3D;的方式实现.</p>
<h2 id="Redis-最适合的场景？"><a href="#Redis-最适合的场景？" class="headerlink" title="Redis 最适合的场景？"></a>Redis 最适合的场景？</h2><p>Redis 是一个开源（BSD 许可），基于内存，支持多种数据结构的存储系统。可以作为数据库、缓存和消息中间件。它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。根据它的特性，它适用的场景有：</p>
<ol>
<li>会话缓存<br>会话（Session）是存储在服务端的，但是可以设置存储的时候不以文件的方式存储，而是存到 Redis 中，而且 Redis 支持数据持久化，不用担心数据因为服务器重启导致 Session 数据丢失的问题。这样做的好处不只是提高获取会话的速度，也对网站的整体性能有很大的提升。</li>
<li>数据缓存<br>Redis 支持多种数据结构，经常被用来做缓存中间件使用。缓存的数据不只是包括数据库中的数据，也可以缓存一些需要临时存储的数据，例如 token、会话数据等。</li>
<li>队列<br>Redis 是支持列表（lists）功能的，可以简单实现一个队列的功能，对数据进行入队、出队操作。实现的队列可以应用到电商的秒杀场景中。</li>
<li>排行榜、计数器<br>Redis 提供了有序集合，可以对数据进行排名，实现排行榜功能。 其次 Redis 中提供了 incr 对数字加 1 命令，也提供了 decr 对数字减 1 命令，所以可以实现一个简单的计数器功能。</li>
<li>发布、订阅功能<br>Redis 中提供了发布订阅相关的命令，可以用来做一些跟发布订阅相关的场景应用等。例如简单的消息队列功能等。<h2 id="什么是-Redis-事务？原理是什么？"><a href="#什么是-Redis-事务？原理是什么？" class="headerlink" title="什么是 Redis 事务？原理是什么？"></a>什么是 Redis 事务？原理是什么？</h2>Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。<br>它的原理是先将属于一个事务的命令发送给 Redis，然后依次执行这些命令。<h2 id="Redis-事务的注意点有哪些？"><a href="#Redis-事务的注意点有哪些？" class="headerlink" title="Redis 事务的注意点有哪些？"></a>Redis 事务的注意点有哪些？</h2>需要注意的点有：<br>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；<br>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。<h2 id="Redis-为什么不支持回滚？"><a href="#Redis-为什么不支持回滚？" class="headerlink" title="Redis 为什么不支持回滚？"></a>Redis 为什么不支持回滚？</h2>Redis 的事务不支持回滚，但是执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。<h2 id="Redis-如何设置密码及验证密码？"><a href="#Redis-如何设置密码及验证密码？" class="headerlink" title="Redis 如何设置密码及验证密码？"></a>Redis 如何设置密码及验证密码？</h2>Redis 密码设置有两种方式：<br>修改配置文件，需要重启 Redis。在 redis.conf 中可以找到 requirepass 参数，设置 Redis 的访问密码。配置方法为：requirepass 访问密码。<br>使用命令设置，不需要重启 Redis。使用命令设置的方法为：config set requirepass 访问密码。如果需要查询密码，可以使用 config get requirepass 命令。如果需要验证密码，可以使用 auth 访问密码，再执行 config get requirepass 获取。<br>需要注意的是，通过这种方式设置访问密码，如果 redis.conf 配置文件中没有设置对应的访问密码，那么服务器重启后访问密码会失效。<h2 id="Redis-单点吞吐量有多少？"><a href="#Redis-单点吞吐量有多少？" class="headerlink" title="Redis 单点吞吐量有多少？"></a>Redis 单点吞吐量有多少？</h2>单点 TPS 达到 8 万&#x2F;秒，QPS 达到 10 万&#x2F;秒。TPS 和 QPS 的意思：<br>QPS：应用系统每秒钟最大能接受的用户访问量。每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在 Server 中有个 counter，每处理一个请求加 1，1s 后 counter&#x3D;QPS。<br>TPS：每秒钟最大能处理的请求数。每秒钟处理完的事务次数，一个应用系统 1s 能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用 QPS 比较合理。</li>
</ol>
<h2 id="Redis-中管道有什么用？"><a href="#Redis-中管道有什么用？" class="headerlink" title="Redis 中管道有什么用？"></a>Redis 中管道有什么用？</h2><p>使用 pipeline（管道）的好处在于可以将多次 I&#x2F;O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。</p>
<h2 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h2><p>因为 Redis 在重启才能加载配置项中的配置，所以需要重启才能生效。针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。<br>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。<br>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
<h2 id="分布式锁-Redis"><a href="#分布式锁-Redis" class="headerlink" title="分布式锁-Redis"></a>分布式锁-Redis</h2><p>实现基础<br>首先Redis是单线程的，这里的单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。而且Redis的性能很好，即使在多个服务争抢锁的时候也能够从容处理众多请求。</p>
<p>方案1<br>加锁命令  SET [KEY] [VALUE] NX<br>解锁命令  DEL [KEY]<br>这是最基础的使用方式，加锁时因为存在NX关键词，所以只有当该KEY不存在的才能成功加锁。解锁时直接删除即可。<br>这种方式也需单机Demo中能够正常运行，但是在分布式环境中就会产生其他问题。</p>
<p>如果某项业务在加锁后程序未执行解锁便退出了，这种情况下，将会造成死锁的情况 ，该位置的锁会永远不能解锁。</p>
<p>方案2<br>基于上面的弊端与缺陷，我们改进加锁命令就有：<br>加锁命令 SET [KEY] [VALUE] NX PX 30000<br>解锁命令 DEL [KEY]<br>在加锁命令中，同时为该锁设置一个过期时间，可以一定程度上避免方案1中出现的死锁情况。<br>现方案会有两个问题：</p>
<p>解锁指令不够健壮，可能会导致误解锁的情况。<br>如果加锁者与解锁者不是同一个，业务可能会导致许多问题。<br>过期时间可能会与业务运行情况强行相关，且影响性能。<br>过期时间设置得过短，可能在业务没运行完的时候就解锁了；过期时间设置过长，在加锁者宕机的情况下，其他服务器等待时间过长，影响性能。</p>
<p>方案3 #<br>加锁命令SET [KEY] [VALUE] NX PX 30000<br>解锁命令<br>if redis.call (“get”,KEYS[1]) &#x3D;&#x3D; ARGV[1] then<br>  return redis.call(“del”,KEYS[1])<br>else<br>  return 0<br>End<br>修改：<br>1.设置保护线程在加锁成功后不断的更新过期时间。<br>2. 解锁命令由Lua脚本替代。由于解锁命令需要进行两次Redis操作，第一步为判断该KEY的VALUE和输入的VALUE是否一致，是的情况下进行第二步，删除该KEY，Redis中可以保证每一条命令是原子性的，但是连续两条命令是并不能保证，因此使用Lua脚本可以将两条命令合二为一，使解锁命令为原子操作。</p>
<p> Redisson - WatchDog<br>Redisson中已经实现的WatchDog机制，也就是方案三种的守护线程的工作。</p>
<p>大家都知道，如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。</p>
<p>Redisson中的WatchDog机制是一种无限递归调用的方式，该方法的定义为：</p>
<p>updateExpireTime(){<br>  async{<br>    sleep(5000);<br>    setExpireTime();<br>    updateExpireTime();<br>  }<br>}<br>该方法通过异步调用形式，能够以每5min的频率更新Expire值</p>
<p>Redis的部署模式有3种：<br>单机部署<br>Master-Slave<br>集群<br>不论是方案3还是方案4，在单机中能够正常运行，但是并不能达到高可用性的要求。如果是主从模式，如果发生在Master节点加锁后，锁信息还未通知到Slave节点的情况下，锁信息会丢失，所以在高可用上仍然有一些问题，因此Redis的作者提出了RedLock算法来解决该问题。</p>
<p>RedLock<br>antirez提出的redlock算法大概是这样的：</p>
<p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<p>·  获取当前Unix时间，以毫秒为单位。<br>·  依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。<br>·  客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（N&#x2F;2+1，这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。<br>·  如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。<br>·  如果因为某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91539644">《进大厂系列》系列-Redis常见面试题（带答案）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903982066827277">《吊打面试官》系列-Redis基础</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903986475057165">《吊打面试官》系列-缓存雪崩、击穿、穿透</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903989184577550">《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903991562747912">Redis双写一致性、并发竞争、线程模型</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903982209449991">Redis-避免缓存穿透的利器之BloomFilter</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000038748352">总结一波 Redis 面试题，收藏起来！</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/103522351">Redis面试题</a></li>
<li><a target="_blank" rel="noopener" href="http://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/%E6%9C%80%E5%85%A8%E7%9A%84%20116%20%E9%81%93%20Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94.md">最全的 116 道 Redis 面试题解答</a></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/java/">java</a><a class="link-muted mr-2" rel="tag" href="/tags/redis/">redis</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/05/18/java/java-redis/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">java redis</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/04/13/spring/spring-Scheduled/"><span class="level-item">spring @Scheduled</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "0c74daaf96a9ae5ca8536f6c65573071",
            repo: "luochunhai.github.io",
            owner: "luochunhai",
            clientID: "f9e12149d698e263599f",
            clientSecret: "5b76add2cdaa3ec47402cde6dc3bb5d913c7c48c",
            admin: ["luochunhai"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Luo Chunhai"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Luo Chunhai</p><p class="is-size-6 is-block">Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>四川·成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">207</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">74</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/luochunhai" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/RocketMQ/"><span class="level-start"><span class="level-item">RocketMQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/cubrid/"><span class="level-start"><span class="level-item">cubrid</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/frontend/"><span class="level-start"><span class="level-item">frontend</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/game-engine/"><span class="level-start"><span class="level-item">game engine</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/categories/jedis/"><span class="level-start"><span class="level-item">jedis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/kafka/"><span class="level-start"><span class="level-item">kafka</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/kubernetes/"><span class="level-start"><span class="level-item">kubernetes</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/mongodb/"><span class="level-start"><span class="level-item">mongodb</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/netty/"><span class="level-start"><span class="level-item">netty</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/opencv/"><span class="level-start"><span class="level-item">opencv</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/oracle/"><span class="level-start"><span class="level-item">oracle</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/quarkus/"><span class="level-start"><span class="level-item">quarkus</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/reactive/"><span class="level-start"><span class="level-item">reactive</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/spring/"><span class="level-start"><span class="level-item">spring</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/study/"><span class="level-start"><span class="level-item">study</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vmware/"><span class="level-start"><span class="level-item">vmware</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/wsl/"><span class="level-start"><span class="level-item">wsl</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/zookeeper/"><span class="level-start"><span class="level-item">zookeeper</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8B%A6%E6%88%AA-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">拦截/抓包工具</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构和算法</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kruskal/"><span class="tag">Kruskal</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Object-Storage/"><span class="tag">Object Storage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RocketMQ/"><span class="tag">RocketMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebSockets/"><span class="tag">WebSockets</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ansible/"><span class="tag">ansible</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cocos/"><span class="tag">cocos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cubrid/"><span class="tag">cubrid</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dijkstra/"><span class="tag">dijkstra</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker-compose/"><span class="tag">docker compose</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dubbo/"><span class="tag">dubbo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filebeat/"><span class="tag">filebeat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flink/"><span class="tag">flink</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gc/"><span class="tag">gc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/graph/"><span class="tag">graph</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/http-server/"><span class="tag">http-server</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/j-u-c/"><span class="tag">j.u.c</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java%E9%94%81/"><span class="tag">java锁</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jdk/"><span class="tag">jdk</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jedis/"><span class="tag">jedis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kafka/"><span class="tag">kafka</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kibana/"><span class="tag">kibana</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kubernetes/"><span class="tag">kubernetes</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lettuce/"><span class="tag">lettuce</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logstash/"><span class="tag">logstash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/maven/"><span class="tag">maven</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/metrics/"><span class="tag">metrics</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mongodb/"><span class="tag">mongodb</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mq/"><span class="tag">mq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis-plus/"><span class="tag">mybatis-plus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/netty/"><span class="tag">netty</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/network/"><span class="tag">network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/opencv/"><span class="tag">opencv</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oracle/"><span class="tag">oracle</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pulsar/"><span class="tag">pulsar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/quarkus/"><span class="tag">quarkus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/reactive/"><span class="tag">reactive</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-batch/"><span class="tag">spring batch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springdoc/"><span class="tag">springdoc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/springfox/"><span class="tag">springfox</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/study/"><span class="tag">study</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tomcat/"><span class="tag">tomcat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/unity/"><span class="tag">unity</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/unreal/"><span class="tag">unreal</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmware/"><span class="tag">vmware</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/volatile/"><span class="tag">volatile</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webflux/"><span class="tag">webflux</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wsl/"><span class="tag">wsl</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zookeeper/"><span class="tag">zookeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%B2/"><span class="tag">串</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><span class="tag">二分查找</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"><span class="tag">优先队列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A0%86/"><span class="tag">堆</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8B%A6%E6%88%AA-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"><span class="tag">拦截/抓包工具</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><span class="tag">数据结构和算法</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91/"><span class="tag">树</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">4</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Redis-的数据类型有哪些"><span class="level-left"><span class="level-item">1</span><span class="level-item">Redis 的数据类型有哪些</span></span></a></li><li><a class="level is-mobile" href="#Redis-持久化机制"><span class="level-left"><span class="level-item">2</span><span class="level-item">Redis 持久化机制</span></span></a></li><li><a class="level is-mobile" href="#缓存雪崩、缓存穿透、击穿、缓存预热、缓存更新、缓存降级等问题"><span class="level-left"><span class="level-item">3</span><span class="level-item">缓存雪崩、缓存穿透、击穿、缓存预热、缓存更新、缓存降级等问题</span></span></a></li><li><a class="level is-mobile" href="#热点数据和冷数据是什么"><span class="level-left"><span class="level-item">4</span><span class="level-item">热点数据和冷数据是什么</span></span></a></li><li><a class="level is-mobile" href="#Memcache与Redis的区别都有哪些？"><span class="level-left"><span class="level-item">5</span><span class="level-item">Memcache与Redis的区别都有哪些？</span></span></a></li><li><a class="level is-mobile" href="#Redis-相比-Memcached-有哪些优势？"><span class="level-left"><span class="level-item">6</span><span class="level-item">Redis 相比 Memcached 有哪些优势？</span></span></a></li><li><a class="level is-mobile" href="#单线程的redis为什么这么快"><span class="level-left"><span class="level-item">7</span><span class="level-item">单线程的redis为什么这么快</span></span></a></li><li><a class="level is-mobile" href="#redis的过期策略以及内存淘汰机制"><span class="level-left"><span class="level-item">8</span><span class="level-item">redis的过期策略以及内存淘汰机制</span></span></a></li><li><a class="level is-mobile" href="#Redis-为什么是单线程的"><span class="level-left"><span class="level-item">9</span><span class="level-item">Redis 为什么是单线程的</span></span></a></li><li><a class="level is-mobile" href="#同时有多个子系统去set一个key。这个时候要注意什么呢？"><span class="level-left"><span class="level-item">10</span><span class="level-item">同时有多个子系统去set一个key。这个时候要注意什么呢？</span></span></a></li><li><a class="level is-mobile" href="#有没有尝试进行多机redis-的部署？如何保证数据一致的？"><span class="level-left"><span class="level-item">11</span><span class="level-item">有没有尝试进行多机redis 的部署？如何保证数据一致的？</span></span></a></li><li><a class="level is-mobile" href="#对于大量的请求怎么样处理"><span class="level-left"><span class="level-item">12</span><span class="level-item">对于大量的请求怎么样处理</span></span></a></li><li><a class="level is-mobile" href="#Redis-常见性能问题和解决方案？"><span class="level-left"><span class="level-item">13</span><span class="level-item">Redis 常见性能问题和解决方案？</span></span></a></li><li><a class="level is-mobile" href="#讲解下Redis线程模型"><span class="level-left"><span class="level-item">14</span><span class="level-item">讲解下Redis线程模型</span></span></a></li><li><a class="level is-mobile" href="#为什么Redis的操作是原子性的，怎么保证原子性的？"><span class="level-left"><span class="level-item">15</span><span class="level-item">为什么Redis的操作是原子性的，怎么保证原子性的？</span></span></a></li><li><a class="level is-mobile" href="#Redis-最适合的场景？"><span class="level-left"><span class="level-item">16</span><span class="level-item">Redis 最适合的场景？</span></span></a></li><li><a class="level is-mobile" href="#什么是-Redis-事务？原理是什么？"><span class="level-left"><span class="level-item">17</span><span class="level-item">什么是 Redis 事务？原理是什么？</span></span></a></li><li><a class="level is-mobile" href="#Redis-事务的注意点有哪些？"><span class="level-left"><span class="level-item">18</span><span class="level-item">Redis 事务的注意点有哪些？</span></span></a></li><li><a class="level is-mobile" href="#Redis-为什么不支持回滚？"><span class="level-left"><span class="level-item">19</span><span class="level-item">Redis 为什么不支持回滚？</span></span></a></li><li><a class="level is-mobile" href="#Redis-如何设置密码及验证密码？"><span class="level-left"><span class="level-item">20</span><span class="level-item">Redis 如何设置密码及验证密码？</span></span></a></li><li><a class="level is-mobile" href="#Redis-单点吞吐量有多少？"><span class="level-left"><span class="level-item">21</span><span class="level-item">Redis 单点吞吐量有多少？</span></span></a></li><li><a class="level is-mobile" href="#Redis-中管道有什么用？"><span class="level-left"><span class="level-item">22</span><span class="level-item">Redis 中管道有什么用？</span></span></a></li><li><a class="level is-mobile" href="#修改配置不重启-Redis-会实时生效吗？"><span class="level-left"><span class="level-item">23</span><span class="level-item">修改配置不重启 Redis 会实时生效吗？</span></span></a></li><li><a class="level is-mobile" href="#分布式锁-Redis"><span class="level-left"><span class="level-item">24</span><span class="level-item">分布式锁-Redis</span></span></a></li><li><a class="level is-mobile" href="#参考文章"><span class="level-left"><span class="level-item">25</span><span class="level-item">参考文章</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-24T07:59:35.000Z">2022-05-24</time></p><p class="title"><a href="/2022/05/24/oracle/oracle-vs_mysql/">MySQL和Oracle的区别</a></p><p class="categories"><a href="/categories/oracle/">oracle</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-24T07:59:35.000Z">2022-05-24</time></p><p class="title"><a href="/2022/05/24/oracle/oracle-intro/">oracle intro</a></p><p class="categories"><a href="/categories/oracle/">oracle</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-18T06:25:41.000Z">2022-05-18</time></p><p class="title"><a href="/2022/05/18/java/java-offer/">java</a></p><p class="categories"><a href="/categories/java/">java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-18T06:25:41.000Z">2022-05-18</time></p><p class="title"><a href="/2022/05/18/java/java-redis/">java redis</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-18T06:25:41.000Z">2022-05-18</time></p><p class="title"><a href="/2022/05/18/java/java-redis2/">java redis2</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Summer</a><p class="is-size-7"><span>&copy; 2022 Luo Chunhai</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>